<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/wiki - Interactive Demo</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f5f5f5;
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      color: #2c3e50;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      color: #7f8c8d;
      margin-bottom: 30px;
      font-size: 1.1em;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    section {
      background: white;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    section.full-width {
      grid-column: 1 / -1;
    }

    #test-runner {
      border: 3px solid #3498db;
      background: #f8fbff;
    }

    h2 {
      color: #2c3e50;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3498db;
      font-size: 1.5em;
    }

    h3 {
      color: #34495e;
      margin: 15px 0 10px 0;
      font-size: 1.2em;
    }

    p.description {
      color: #7f8c8d;
      margin-bottom: 15px;
      font-size: 0.95em;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 500;
      font-size: 0.9em;
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
      transition: border-color 0.3s;
    }

    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #3498db;
    }

    textarea {
      resize: vertical;
      min-height: 100px;
      font-family: 'Courier New', monospace;
    }

    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.3s;
      margin-right: 10px;
      margin-bottom: 10px;
    }

    button:hover {
      background: #2980b9;
    }

    button.run-all {
      background: #27ae60;
      font-size: 18px;
      padding: 15px 30px;
      font-weight: bold;
    }

    button.run-all:hover {
      background: #229954;
    }

    button.secondary {
      background: #95a5a6;
    }

    button.secondary:hover {
      background: #7f8c8d;
    }

    button.danger {
      background: #e74c3c;
    }

    button.danger:hover {
      background: #c0392b;
    }

    button.success {
      background: #27ae60;
    }

    button.success:hover {
      background: #229954;
    }

    .output {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 15px;
      margin-top: 15px;
      max-height: 300px;
      overflow-y: auto;
    }

    .output.empty {
      color: #999;
      font-style: italic;
    }

    .test-output {
      background: #f5f5f5;
      padding: 15px;
      font-family: 'Courier New', monospace;
      white-space: pre-wrap;
      max-height: 500px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-top: 15px;
      font-size: 13px;
      line-height: 1.5;
    }

    .test-pass {
      color: #27ae60;
      font-weight: bold;
    }

    .test-fail {
      color: #e74c3c;
      font-weight: bold;
    }

    .test-running {
      color: #f39c12;
      font-weight: bold;
    }

    .summary {
      font-size: 20px;
      font-weight: bold;
      margin-top: 15px;
      padding: 15px;
      border-radius: 4px;
      background: #fff;
      border: 2px solid #ddd;
    }

    .summary.all-pass {
      background: #d4edda;
      border-color: #27ae60;
      color: #155724;
    }

    .summary.has-fail {
      background: #f8d7da;
      border-color: #e74c3c;
      color: #721c24;
    }

    pre {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      margin-top: 10px;
      font-size: 13px;
      line-height: 1.4;
    }

    .page-card {
      background: white;
      border: 1px solid #e1e8ed;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 10px;
      transition: box-shadow 0.3s;
    }

    .page-card:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .page-card h4 {
      color: #2c3e50;
      margin-bottom: 8px;
      font-size: 1.1em;
    }

    .page-card .page-id {
      color: #95a5a6;
      font-size: 0.85em;
      font-family: monospace;
      margin-bottom: 8px;
    }

    .page-card .page-content {
      color: #555;
      font-size: 0.9em;
      line-height: 1.5;
      margin-bottom: 8px;
      white-space: pre-wrap;
    }

    .page-card .page-meta {
      display: flex;
      gap: 15px;
      font-size: 0.85em;
      color: #7f8c8d;
      margin-top: 10px;
    }

    .tag {
      display: inline-block;
      background: #3498db;
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.8em;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    .type-badge {
      display: inline-block;
      background: #9b59b6;
      color: white;
      padding: 3px 10px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: 500;
    }

    .wiki-link {
      color: #3498db;
      text-decoration: none;
      border-bottom: 1px dashed #3498db;
      cursor: pointer;
    }

    .wiki-link:hover {
      color: #2980b9;
      border-bottom-style: solid;
    }

    .dead-link {
      color: #e74c3c;
      border-bottom: 1px dashed #e74c3c;
    }

    .success-message {
      background: #d4edda;
      color: #155724;
      padding: 12px;
      border-radius: 4px;
      margin-top: 10px;
      border-left: 4px solid #28a745;
    }

    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 12px;
      border-radius: 4px;
      margin-top: 10px;
      border-left: 4px solid #dc3545;
    }

    .event-log {
      max-height: 200px;
      overflow-y: auto;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 10px;
    }

    .event-item {
      padding: 8px;
      margin-bottom: 5px;
      border-left: 3px solid #3498db;
      background: white;
      font-size: 0.9em;
    }

    .event-item.create { border-left-color: #27ae60; }
    .event-item.update { border-left-color: #f39c12; }
    .event-item.delete { border-left-color: #e74c3c; }
    .event-item.rename { border-left-color: #9b59b6; }

    .event-time {
      color: #95a5a6;
      font-size: 0.85em;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-card.blue {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .stat-card.green {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    }

    .stat-card.orange {
      background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
    }

    .stat-card.purple {
      background: linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%);
    }

    .stat-value {
      font-size: 2.5em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 0.9em;
      opacity: 0.9;
    }

    .flex-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .info-box {
      background: #e7f3ff;
      border-left: 4px solid #3498db;
      padding: 12px;
      margin: 15px 0;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .graph-viz {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 15px;
      margin-top: 15px;
      font-family: monospace;
      font-size: 0.9em;
      line-height: 1.8;
    }

    .link-list {
      list-style: none;
      padding: 0;
    }

    .link-list li {
      padding: 8px;
      margin-bottom: 5px;
      background: #f8f9fa;
      border-left: 3px solid #3498db;
      border-radius: 3px;
    }

    .inline-controls {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      margin-bottom: 15px;
    }

    .inline-controls .control-group {
      flex: 1;
      margin-bottom: 0;
    }

    .progress-bar {
      width: 100%;
      height: 30px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin: 15px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #27ae60, #2ecc71);
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .container {
        grid-template-columns: 1fr;
      }

      body {
        padding: 10px;
      }

      h1 {
        font-size: 2em;
      }
    }
  </style>
</head>
<body>
  <h1>@motioneffector/wiki</h1>
  <p class="subtitle">Interactive demonstration with automated tests and manual exploration</p>

  <section id="test-runner" class="full-width">
    <h2>üß™ Automated Test Suite</h2>
    <p class="description">Comprehensive tests covering all public API methods, error handling, and edge cases.</p>

    <div class="flex-buttons">
      <button class="run-all" onclick="runAllTests()">‚ñ∂ Run All Tests</button>
      <button class="secondary" onclick="clearResults()">Clear Results</button>
    </div>

    <div class="progress-bar" id="progressBar" style="display: none;">
      <div class="progress-fill" id="progressFill">0%</div>
    </div>

    <div class="summary" id="summary"></div>
    <div class="test-output" id="testOutput"></div>
  </section>

  <section class="full-width">
    <h2>üìä Wiki Statistics</h2>
    <div class="stats-grid" id="statsGrid">
      <div class="stat-card blue">
        <div class="stat-value" id="statPages">0</div>
        <div class="stat-label">Total Pages</div>
      </div>
      <div class="stat-card green">
        <div class="stat-value" id="statLinks">0</div>
        <div class="stat-label">Total Links</div>
      </div>
      <div class="stat-card orange">
        <div class="stat-value" id="statOrphans">0</div>
        <div class="stat-label">Orphan Pages</div>
      </div>
      <div class="stat-card purple">
        <div class="stat-value" id="statDeadLinks">0</div>
        <div class="stat-label">Dead Links</div>
      </div>
    </div>
  </section>

  <div class="container">
    <section>
      <h2>üìù Create Page</h2>
      <p class="description">Create wiki pages with [[double bracket]] links. Try linking to other pages!</p>

      <div class="control-group">
        <label for="pageTitle">Page Title:</label>
        <input type="text" id="pageTitle" placeholder="e.g., Kingdom of Aldoria">
      </div>

      <div class="control-group">
        <label for="pageContent">Content (use [[Page Name]] for links):</label>
        <textarea id="pageContent" placeholder="Founded by [[King Aldric I]] after the [[Battle of Five Rivers]]."></textarea>
      </div>

      <div class="control-group">
        <label for="pageType">Type (optional):</label>
        <select id="pageType">
          <option value="">-- None --</option>
          <option value="person">Person</option>
          <option value="place">Place</option>
          <option value="event">Event</option>
          <option value="concept">Concept</option>
          <option value="organization">Organization</option>
        </select>
      </div>

      <div class="control-group">
        <label for="pageTags">Tags (comma-separated, optional):</label>
        <input type="text" id="pageTags" placeholder="e.g., history, important, magic">
      </div>

      <div class="flex-buttons">
        <button onclick="createPage()">Create Page</button>
        <button class="success" onclick="loadExampleData()">Load Example Wiki</button>
        <button class="secondary" onclick="clearForm()">Clear Form</button>
      </div>

      <div id="createOutput"></div>
    </section>

    <section>
      <h2>üîç Get Page</h2>
      <p class="description">Retrieve pages by ID or title.</p>

      <div class="control-group">
        <label for="getPageId">Page ID:</label>
        <input type="text" id="getPageId" placeholder="e.g., kingdom-of-aldoria">
      </div>
      <button onclick="getPageById()">Get by ID</button>

      <div class="control-group" style="margin-top: 15px;">
        <label for="getPageTitle">Page Title:</label>
        <input type="text" id="getPageTitle" placeholder="e.g., Kingdom of Aldoria">
      </div>
      <div class="flex-buttons">
        <button onclick="getPageByTitle(false)">Get by Title (exact)</button>
        <button onclick="getPageByTitle(true)">Get by Title (ignore case)</button>
      </div>

      <div id="getPageOutput" class="output empty">Page details will appear here</div>
    </section>
  </div>

  <div class="container">
    <section>
      <h2>‚úèÔ∏è Update Page</h2>
      <p class="description">Update existing page content, title, type, or tags.</p>

      <div class="control-group">
        <label for="updatePageId">Page ID:</label>
        <input type="text" id="updatePageId" placeholder="e.g., kingdom-of-aldoria">
      </div>

      <div class="control-group">
        <label for="updateContent">New Content:</label>
        <textarea id="updateContent" placeholder="Updated content with [[new links]]"></textarea>
      </div>

      <div class="flex-buttons">
        <button onclick="updatePage()">Update Page</button>
        <button class="secondary" onclick="loadPageForUpdate()">Load Page</button>
      </div>

      <div id="updateOutput"></div>
    </section>

    <section>
      <h2>üîÑ Rename Page</h2>
      <p class="description">Rename a page and optionally update its ID.</p>

      <div class="control-group">
        <label for="renamePageId">Page ID:</label>
        <input type="text" id="renamePageId" placeholder="e.g., old-page">
      </div>

      <div class="control-group">
        <label for="renameNewTitle">New Title:</label>
        <input type="text" id="renameNewTitle" placeholder="New Page Name">
      </div>

      <div class="flex-buttons">
        <button onclick="renamePage(false)">Rename (keep ID)</button>
        <button onclick="renamePage(true)">Rename + Update ID</button>
      </div>

      <div id="renameOutput"></div>
    </section>
  </div>

  <section class="full-width">
    <h2>üìö All Pages</h2>
    <p class="description">View all pages in the wiki. Click links to see connections.</p>

    <div class="inline-controls">
      <div class="control-group">
        <label for="filterType">Filter by Type:</label>
        <select id="filterType">
          <option value="">All Types</option>
        </select>
      </div>
      <div class="control-group">
        <label for="filterTags">Filter by Tag:</label>
        <select id="filterTags">
          <option value="">All Tags</option>
        </select>
      </div>
      <div class="control-group">
        <label for="sortBy">Sort By:</label>
        <select id="sortBy">
          <option value="created">Created (newest)</option>
          <option value="modified">Modified (newest)</option>
          <option value="title">Title (A-Z)</option>
        </select>
      </div>
      <button onclick="refreshPagesList()">Refresh</button>
    </div>

    <div id="pagesList" class="output empty">No pages yet. Create your first page above!</div>
  </section>

  <div class="container">
    <section>
      <h2>üîó Links & Backlinks</h2>
      <p class="description">Explore bidirectional linking between pages.</p>

      <div class="control-group">
        <label for="linksPageId">Page ID:</label>
        <input type="text" id="linksPageId" placeholder="e.g., kingdom-of-aldoria">
      </div>

      <button onclick="showLinks()">Show Links</button>

      <div id="linksOutput" class="output empty">Links will appear here</div>
    </section>

    <section>
      <h2>üåê Graph Exploration</h2>
      <p class="description">Visualize page connections and traverse the link graph.</p>

      <div class="control-group">
        <label for="graphStartId">Start Page ID:</label>
        <input type="text" id="graphStartId" placeholder="e.g., kingdom-of-aldoria">
      </div>

      <div class="control-group">
        <label for="graphDepth">Connection Depth:</label>
        <select id="graphDepth">
          <option value="0">0 (page only)</option>
          <option value="1" selected>1 (direct links)</option>
          <option value="2">2 (2 hops)</option>
          <option value="3">3 (3 hops)</option>
        </select>
      </div>

      <div class="flex-buttons">
        <button onclick="showConnectedPages()">Show Connected</button>
        <button class="secondary" onclick="showFullGraph()">Show Full Graph</button>
      </div>

      <div id="graphOutput" class="output empty">Graph will appear here</div>
    </section>
  </div>

  <div class="container">
    <section>
      <h2>üîé Search</h2>
      <p class="description">Full-text search across titles, content, and tags.</p>

      <div class="control-group">
        <label for="searchQuery">Search Query:</label>
        <input type="text" id="searchQuery" placeholder="e.g., magic, kingdom, battle">
      </div>

      <div class="control-group">
        <label>Search In:</label>
        <div style="display: flex; gap: 15px; margin-top: 5px;">
          <label style="display: flex; align-items: center; gap: 5px;">
            <input type="checkbox" id="searchTitle" checked> Title
          </label>
          <label style="display: flex; align-items: center; gap: 5px;">
            <input type="checkbox" id="searchContent" checked> Content
          </label>
          <label style="display: flex; align-items: center; gap: 5px;">
            <input type="checkbox" id="searchTags" checked> Tags
          </label>
        </div>
      </div>

      <button onclick="searchWiki()">Search</button>

      <div id="searchOutput" class="output empty">Search results will appear here</div>
    </section>

    <section>
      <h2>‚ö†Ô∏è Dead Links & Orphans</h2>
      <p class="description">Find broken links and disconnected pages.</p>

      <div class="flex-buttons">
        <button onclick="showDeadLinks()">Show Dead Links</button>
        <button onclick="showOrphans()">Show Orphans</button>
      </div>

      <div id="deadLinksOutput" class="output empty">Results will appear here</div>
    </section>
  </div>

  <div class="container">
    <section>
      <h2>üì§ Export / Import</h2>
      <p class="description">Export wiki data as JSON or import from JSON.</p>

      <div class="flex-buttons">
        <button onclick="exportWiki()">Export to JSON</button>
        <button class="success" onclick="importFromClipboard()">Import from Clipboard</button>
      </div>

      <div class="control-group" style="margin-top: 15px;">
        <label for="importMode">Import Mode:</label>
        <select id="importMode">
          <option value="replace">Replace (clear existing)</option>
          <option value="merge">Merge (overwrite conflicts)</option>
          <option value="skip">Skip (keep existing)</option>
        </select>
      </div>

      <div id="exportOutput" class="output empty">Export/Import results will appear here</div>
    </section>

    <section>
      <h2>üóëÔ∏è Delete Page</h2>
      <p class="description">Remove pages from the wiki. Backlinks become dead links.</p>

      <div class="control-group">
        <label for="deletePageId">Page ID:</label>
        <input type="text" id="deletePageId" placeholder="e.g., old-page">
      </div>

      <button class="danger" onclick="deletePage()">Delete Page</button>

      <div id="deleteOutput"></div>
    </section>
  </div>

  <section class="full-width">
    <h2>üì° Live Events</h2>
    <p class="description">Real-time notifications for all wiki changes.</p>

    <div class="flex-buttons">
      <button class="secondary" onclick="clearEvents()">Clear Events</button>
    </div>

    <div id="eventLog" class="event-log">
      <div style="color: #999; font-style: italic;">Events will appear here...</div>
    </div>
  </section>

  <script>
    // ============================================
    // INLINED LIBRARY CODE (from dist/index.js)
    // ============================================
    class S extends Error {
      constructor(c) {
        super(c), this.name = "WikiError", Object.setPrototypeOf(this, new.target.prototype);
      }
    }
    class E extends S {
      constructor(c, w) {
        super(c), this.field = w, this.name = "ValidationError";
      }
    }
    class N extends S {
      constructor(c) {
        super(c), this.name = "StorageError";
      }
    }
    const D = /\[\[([^\]|]+)(?:\|[^\]]*)?\]\]/g;
    function C(l, c = D) {
      var p;
      const w = $(l), i = [], d = /* @__PURE__ */ new Set();
      c.lastIndex = 0;
      const m = new RegExp(c.source, "g");
      let v;
      for (; (v = m.exec(w)) !== null; ) {
        let g = (p = v[1]) == null ? void 0 : p.trim();
        g != null && g.includes(`
`) || (g && (g = g.replace(/^\[+/, "")), g && g.length > 0 && !d.has(g) && (i.push(g), d.add(g)));
      }
      return i;
    }
    function $(l) {
      let c = l;
      return c = c.replace(/```[\s\S]*?```/g, ""), c = c.replace(/~~~[\s\S]*?~~~/g, ""), c = c.replace(/``[^`]*?``/g, ""), c = c.replace(/`[^`\n]*?`/g, ""), c = c.replace(/^ {4}.*/gm, ""), c;
    }
    function b() {
      const l = /* @__PURE__ */ new Map();
      return {
        save(c) {
          return l.set(c.id, { ...c }), Promise.resolve();
        },
        load(c) {
          const w = l.get(c);
          return Promise.resolve(w ? { ...w } : null);
        },
        delete(c) {
          return l.delete(c), Promise.resolve();
        },
        list() {
          const c = Array.from(l.values()).map((w) => ({ ...w }));
          return Promise.resolve(c);
        }
      };
    }
    const I = /\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g;
    function R(l) {
      if (l != null && l.storage) {
        const e = l.storage;
        if (typeof e.save != "function" || typeof e.load != "function" || typeof e.delete != "function" || typeof e.list != "function")
          throw new TypeError("Storage must implement WikiStorage interface");
      }
      if (l != null && l.linkPattern) {
        if (!(l.linkPattern instanceof RegExp))
          throw new TypeError("linkPattern must be a RegExp");
        if (!/\([^?]/.test(l.linkPattern.source))
          throw new Error("linkPattern must have at least one capture group");
      }
      const c = (l == null ? void 0 : l.storage) ?? b(), w = (l == null ? void 0 : l.linkPattern) ?? I, i = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Set();
      let p = 1;
      function g(e) {
        const t = e.toLowerCase().trim().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\p{L}\p{N}\s-]/gu, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
        if (t) return t;
        const r = `page-${String(p)}`;
        return p++, r;
      }
      function A(e) {
        if (!i.has(e))
          return e;
        let t = 2;
        for (; i.has(`${e}-${String(t)}`); )
          t++;
        return `${e}-${String(t)}`;
      }
      function L(e, t = !1) {
        if ("title" in e) {
          const r = e.title;
          if (r === void 0) {
            if (!t)
              throw new E("Title is required");
          } else {
            if (typeof r != "string")
              throw new E("Title is required");
            if (r.trim() === "")
              throw new E("Title cannot be empty");
          }
        } else if (!t)
          throw new E("Title is required");
        if ("tags" in e && e.tags !== void 0) {
          if (!Array.isArray(e.tags))
            throw new TypeError("Tags must be an array");
          for (const r of e.tags)
            if (typeof r != "string" || r.trim() === "")
              throw new TypeError("Each tag must be a non-empty string");
        }
        if ("type" in e && e.type !== void 0 && typeof e.type != "string")
          throw new TypeError("Type must be a string");
      }
      function T(e, t) {
        const r = C(t, w), s = new Set(r);
        d.set(e, s);
        for (const o of r) {
          const a = g(o);
          m.has(a) || m.set(a, /* @__PURE__ */ new Set());
          const n = m.get(a);
          n && n.add(e);
        }
      }
      function x(e) {
        var r, s;
        const t = d.get(e) ?? /* @__PURE__ */ new Set();
        for (const o of t) {
          const a = g(o);
          (r = m.get(a)) == null || r.delete(e), ((s = m.get(a)) == null ? void 0 : s.size) === 0 && m.delete(a);
        }
        d.delete(e), m.delete(e);
      }
      function P(e) {
        for (const t of v)
          try {
            t(e);
          } catch (r) {
            console.error("Subscriber error:", r);
          }
      }
      const y = {
        async createPage(e) {
          L(e);
          const t = e.title, r = e.content ?? "";
          let s;
          if (e.id) {
            if (i.has(e.id))
              throw new Error(`Page with id '${e.id}' already exists`);
            s = e.id;
          } else {
            const n = g(t);
            s = A(n);
          }
          const o = /* @__PURE__ */ new Date(), a = {
            id: s,
            title: t,
            content: r,
            ...e.type !== void 0 && { type: e.type },
            ...e.tags !== void 0 && { tags: e.tags },
            created: o,
            modified: o
          };
          return i.set(s, a), T(s, r), await c.save(a), P({ type: "create", page: a }), { ...a };
        },
        getPage(e) {
          if (!e || typeof e != "string")
            return;
          const t = i.get(e);
          return t ? { ...t } : void 0;
        },
        getPageByTitle(e, t) {
          if (!(!e || typeof e != "string")) {
            if (t != null && t.ignoreCase) {
              const r = e.toLowerCase();
              for (const s of i.values())
                if (s.title.toLowerCase() === r)
                  return { ...s };
              return;
            }
            for (const r of i.values())
              if (r.title === e)
                return { ...r };
          }
        },
        async updatePage(e, t) {
          const r = i.get(e);
          if (!r)
            throw new Error(`Page '${e}' not found`);
          L(t, !0);
          const s = { ...r }, o = t.content !== void 0 && t.content !== r.content;
          return t.title !== void 0 && (r.title = t.title), t.content !== void 0 && (r.content = t.content), "type" in t && (t.type === void 0 ? delete r.type : r.type = t.type), "tags" in t && (t.tags === void 0 ? delete r.tags : r.tags = t.tags), r.modified = /* @__PURE__ */ new Date(), o && (x(e), T(e, r.content)), i.set(e, r), await c.save(r), P({ type: "update", page: { ...r }, previous: s }), { ...r };
        },
        async deletePage(e, t) {
          const r = i.get(e);
          if (!r)
            throw new Error(`Page '${e}' not found`);
          const s = { ...r };
          i.delete(e), (t == null ? void 0 : t.updateLinks) !== !1 && x(e), await c.delete(e), P({ type: "delete", page: s });
        },
        async renamePage(e, t, r) {
          if (!t || t.trim() === "")
            throw new Error("Title cannot be empty");
          const s = i.get(e);
          if (!s)
            throw new Error(`Page '${e}' not found`);
          const o = s.title;
          if (s.title = t, s.modified = /* @__PURE__ */ new Date(), r != null && r.updateId) {
            const a = g(t);
            if (a !== e) {
              if (i.has(a))
                throw new Error(`Page with id '${a}' already exists`);
              for (const [f, k] of d.entries()) {
                const h = i.get(f);
                h && k.has(o) && (h.content = h.content.replace(
                  new RegExp(`\\[\\[${B(o)}(\\|[^\\]]+)?\\]\\]`, "g"),
                  `[[${t}$1]]`
                ), await c.save(h));
              }
              i.delete(e), s.id = a, i.set(a, s);
              const n = d.get(e);
              n && (d.delete(e), d.set(a, n));
              const u = m.get(e);
              u && (m.delete(e), m.set(a, u));
              for (const f of d.values()) {
                const k = Array.from(f);
                for (const h of k)
                  g(h) === e && (f.delete(h), f.add(t));
              }
              for (const f of m.values())
                f.has(e) && (f.delete(e), f.add(a));
            }
          }
          return await c.save(s), P({ type: "rename", page: { ...s }, previousTitle: o }), { ...s };
        },
        getLinks(e) {
          const t = d.get(e);
          return t ? Array.from(t) : [];
        },
        getBacklinks(e) {
          const t = m.get(e);
          return t ? Array.from(t) : [];
        },
        getLinkedPages(e) {
          const t = y.getLinks(e), r = [];
          for (const s of t) {
            const o = g(s), a = i.get(o);
            a !== void 0 && r.push({ ...a });
          }
          return r;
        },
        getBacklinkPages(e) {
          return y.getBacklinks(e).map((r) => i.get(r)).filter((r) => r !== void 0).map((r) => ({ ...r }));
        },
        resolveLink(e) {
          return g(e);
        },
        resolveLinkToPage(e) {
          const t = y.resolveLink(e);
          return y.getPage(t);
        },
        getDeadLinks() {
          const e = [];
          for (const [t, r] of d.entries())
            for (const s of r) {
              const o = g(s);
              i.has(o) || e.push({ source: t, target: s });
            }
          return e;
        },
        getDeadLinksForPage(e) {
          const t = d.get(e);
          if (!t) return [];
          const r = [];
          for (const s of t) {
            const o = g(s);
            i.has(o) || r.push(s);
          }
          return r;
        },
        getOrphans() {
          const e = [];
          for (const t of i.values()) {
            const r = m.get(t.id);
            (!r || r.size === 0) && e.push({ ...t });
          }
          return e;
        },
        getGraph() {
          const e = {};
          for (const t of i.values()) {
            const r = d.get(t.id) ?? /* @__PURE__ */ new Set();
            e[t.id] = Array.from(r).map((s) => g(s));
          }
          return e;
        },
        getConnectedPages(e, t = 1) {
          if (!i.get(e)) return [];
          const s = /* @__PURE__ */ new Set(), o = [{ id: e, currentDepth: 0 }], a = /* @__PURE__ */ new Set();
          for (; o.length > 0; ) {
            const n = o.shift();
            if (!(!n || s.has(n.id)) && (s.add(n.id), a.add(n.id), n.currentDepth < t)) {
              const u = y.getLinks(n.id);
              for (const k of u) {
                const h = g(k);
                !s.has(h) && i.has(h) && o.push({ id: h, currentDepth: n.currentDepth + 1 });
              }
              const f = y.getBacklinks(n.id);
              for (const k of f)
                s.has(k) || o.push({ id: k, currentDepth: n.currentDepth + 1 });
            }
          }
          return Array.from(a).map((n) => i.get(n)).filter((n) => !!n).map((n) => ({ ...n }));
        },
        listPages(e) {
          let t = Array.from(i.values());
          if (e != null && e.type && (t = t.filter((n) => n.type === e.type)), e != null && e.tags && e.tags.length > 0) {
            const n = e.tags;
            t = t.filter((u) => {
              const f = u.tags;
              return f ? n.some((k) => f.includes(k)) : !1;
            });
          }
          const r = (e == null ? void 0 : e.sort) ?? "created", s = (e == null ? void 0 : e.order) ?? "desc";
          t.sort((n, u) => {
            let f = 0;
            return r === "title" ? f = n.title.localeCompare(u.title) : r === "created" ? f = n.created.getTime() - u.created.getTime() : f = n.modified.getTime() - u.modified.getTime(), s === "asc" ? f : -f;
          });
          const o = (e == null ? void 0 : e.offset) ?? 0, a = e == null ? void 0 : e.limit;
          if (a !== void 0 && a === 0)
            return [];
          if (o > 0 || a !== void 0) {
            const n = o, u = a !== void 0 ? n + a : void 0;
            t = t.slice(n, u);
          }
          return t.map((n) => ({ ...n }));
        },
        search(e, t) {
          if (!e || e.trim() === "")
            return [];
          const r = e.trim().toLowerCase(), s = (t == null ? void 0 : t.fields) ?? ["title", "content"], o = [];
          for (const n of i.values()) {
            if (t != null && t.type && n.type !== t.type)
              continue;
            let u = 0;
            if (s.includes("title")) {
              const f = n.title.toLowerCase();
              f === r ? u += 100 : f.includes(r) && (u += 50);
            }
            if (s.includes("content") && n.content.toLowerCase().includes(r) && (u += 10), s.includes("tags") && n.tags)
              for (const f of n.tags)
                f.toLowerCase().includes(r) && (u += 20);
            u > 0 && o.push({ page: { ...n }, score: u });
          }
          return o.sort((n, u) => u.score - n.score), (t != null && t.limit ? o.slice(0, t.limit) : o).map((n) => n.page);
        },
        getTags() {
          const e = /* @__PURE__ */ new Set();
          for (const t of i.values())
            if (t.tags)
              for (const r of t.tags)
                e.add(r);
          return Array.from(e).sort();
        },
        getPagesByTag(e) {
          var r;
          const t = [];
          for (const s of i.values())
            (r = s.tags) != null && r.includes(e) && t.push({ ...s });
          return t;
        },
        getTypes() {
          const e = /* @__PURE__ */ new Set();
          for (const t of i.values())
            t.type && e.add(t.type);
          return Array.from(e).sort();
        },
        getPagesByType(e) {
          const t = [];
          for (const r of i.values())
            r.type === e && t.push({ ...r });
          return t;
        },
        export() {
          return Array.from(i.values()).map((e) => ({ ...e }));
        },
        async import(e, t) {
          if (!Array.isArray(e))
            throw new Error("Pages must be an array");
          for (const a of e) {
            if (!a.id)
              throw new Error("Each page must have an id field");
            if (!a.title)
              throw new Error("Each page must have a title field");
          }
          const r = (t == null ? void 0 : t.mode) ?? "replace", s = (t == null ? void 0 : t.emitEvents) ?? !1;
          r === "replace" && (i.clear(), d.clear(), m.clear());
          let o = 0;
          for (const a of e) {
            if (r === "skip" && i.has(a.id))
              continue;
            const n = {
              ...a,
              created: a.created instanceof Date ? a.created : new Date(a.created),
              modified: a.modified instanceof Date ? a.modified : new Date(a.modified)
            };
            i.set(n.id, n), T(n.id, n.content), await c.save(n), o++, s && P({ type: "create", page: { ...n } });
          }
          return o;
        },
        toJSON() {
          const e = y.export();
          return JSON.stringify(e);
        },
        on(e, t) {
          return v.add(t), () => {
            v.delete(t);
          };
        },
        onChange(e) {
          return y.on("change", e);
        }
      };
      return y;
    }
    function B(l) {
      return l.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    // Expose library to window for demo use
    window.createWiki = R;
    window.memoryStorage = b;
    window.WikiError = S;
    window.ValidationError = E;
    window.StorageError = N;
    // ============================================

    // Initialize wiki for manual exploration
    let wiki = createWiki({ storage: memoryStorage() })
    window.wiki = wiki // For debugging

    // Test definitions
    const tests = [
      // === Wiki Creation ===
      {
        name: 'creates wiki instance with no options',
        fn: async () => {
          const w = createWiki()
          if (!w) throw new Error('Wiki is undefined')
          if (typeof w.createPage !== 'function') throw new Error('Missing createPage method')
        }
      },
      {
        name: 'accepts storage adapter option',
        fn: async () => {
          const w = createWiki({ storage: memoryStorage() })
          if (!w) throw new Error('Wiki is undefined')
        }
      },
      {
        name: 'accepts custom link pattern option',
        fn: async () => {
          const w = createWiki({ linkPattern: /\{\{([^}]+)\}\}/g })
          const page = await w.createPage({ title: 'Test', content: '{{Link}}' })
          const links = w.getLinks(page.id)
          if (links.length !== 1 || links[0] !== 'Link') {
            throw new Error(`Expected {{Link}} to be extracted, got: ${links.join(', ')}`)
          }
        }
      },
      {
        name: 'starts with no pages',
        fn: async () => {
          const w = createWiki()
          const pages = w.listPages()
          if (pages.length !== 0) throw new Error(`Expected 0 pages, got ${pages.length}`)
        }
      },
      {
        name: 'throws TypeError if storage is invalid',
        fn: async () => {
          try {
            createWiki({ storage: { notValid: true } })
            throw new Error('Should have thrown TypeError')
          } catch (e) {
            if (e.name !== 'TypeError') throw new Error(`Expected TypeError, got ${e.name}`)
          }
        }
      },
      {
        name: 'throws TypeError if linkPattern is not RegExp',
        fn: async () => {
          try {
            createWiki({ linkPattern: 'not-a-regex' })
            throw new Error('Should have thrown TypeError')
          } catch (e) {
            if (e.name !== 'TypeError') throw new Error(`Expected TypeError, got ${e.name}`)
          }
        }
      },
      {
        name: 'throws Error if linkPattern has no capture group',
        fn: async () => {
          try {
            createWiki({ linkPattern: /\[\[[^\]]+\]\]/g })
            throw new Error('Should have thrown Error')
          } catch (e) {
            if (!e.message.includes('capture group')) {
              throw new Error(`Expected capture group error, got: ${e.message}`)
            }
          }
        }
      },

      // === Page Creation ===
      {
        name: 'creates page with title and content',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Test Page', content: 'Test content' })
          if (page.title !== 'Test Page') throw new Error('Title not set')
          if (page.content !== 'Test content') throw new Error('Content not set')
        }
      },
      {
        name: 'generates id from title if not provided',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'King Aldric I' })
          if (page.id !== 'king-aldric-i') {
            throw new Error(`Expected 'king-aldric-i', got '${page.id}'`)
          }
        }
      },
      {
        name: 'uses provided id exactly if given',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Test', id: 'custom-id' })
          if (page.id !== 'custom-id') throw new Error(`Expected 'custom-id', got '${page.id}'`)
        }
      },
      {
        name: 'throws Error if id already exists',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'First', id: 'duplicate' })
          try {
            await w.createPage({ title: 'Second', id: 'duplicate' })
            throw new Error('Should have thrown Error')
          } catch (e) {
            if (!e.message.includes('already exists')) {
              throw new Error(`Expected 'already exists' error, got: ${e.message}`)
            }
          }
        }
      },
      {
        name: 'appends number if generated slug exists',
        fn: async () => {
          const w = createWiki()
          const p1 = await w.createPage({ title: 'Test' })
          const p2 = await w.createPage({ title: 'Test' })
          const p3 = await w.createPage({ title: 'Test' })
          if (p1.id !== 'test') throw new Error(`Expected 'test', got '${p1.id}'`)
          if (p2.id !== 'test-2') throw new Error(`Expected 'test-2', got '${p2.id}'`)
          if (p3.id !== 'test-3') throw new Error(`Expected 'test-3', got '${p3.id}'`)
        }
      },
      {
        name: 'sets created and modified timestamps',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Test' })
          if (!(page.created instanceof Date)) throw new Error('created is not a Date')
          if (!(page.modified instanceof Date)) throw new Error('modified is not a Date')
        }
      },
      {
        name: 'throws Error for empty title',
        fn: async () => {
          const w = createWiki()
          try {
            await w.createPage({ title: '' })
            throw new Error('Should have thrown Error')
          } catch (e) {
            if (!e.message.includes('empty')) {
              throw new Error(`Expected 'empty' error, got: ${e.message}`)
            }
          }
        }
      },
      {
        name: 'accepts optional type and tags',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({
            title: 'Test',
            type: 'person',
            tags: ['important', 'test']
          })
          if (page.type !== 'person') throw new Error('Type not set')
          if (!page.tags || page.tags.length !== 2) throw new Error('Tags not set')
        }
      },

      // === Link Extraction ===
      {
        name: 'extracts links from content',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({
            title: 'Test',
            content: 'Links to [[Page A]] and [[Page B]]'
          })
          const links = w.getLinks(page.id)
          if (links.length !== 2) throw new Error(`Expected 2 links, got ${links.length}`)
          if (!links.includes('Page A')) throw new Error('Missing Page A')
          if (!links.includes('Page B')) throw new Error('Missing Page B')
        }
      },
      {
        name: 'ignores links in code blocks',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({
            title: 'Test',
            content: '[[Real]]\n```\n[[Not Real]]\n```\n`[[Also Not]]`'
          })
          const links = w.getLinks(page.id)
          if (links.length !== 1 || links[0] !== 'Real') {
            throw new Error(`Expected only 'Real', got: ${links.join(', ')}`)
          }
        }
      },
      {
        name: 'extracts display text syntax [[Page|Display]]',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({
            title: 'Test',
            content: 'Read [[Documentation|the docs]]'
          })
          const links = w.getLinks(page.id)
          if (links.length !== 1 || links[0] !== 'Documentation') {
            throw new Error(`Expected 'Documentation', got: ${links.join(', ')}`)
          }
        }
      },
      {
        name: 'deduplicates repeated links',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({
            title: 'Test',
            content: '[[Link]] and [[Link]] again'
          })
          const links = w.getLinks(page.id)
          if (links.length !== 1) {
            throw new Error(`Expected 1 unique link, got ${links.length}`)
          }
        }
      },

      // === Bidirectional Links ===
      {
        name: 'tracks backlinks automatically',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Target' })
          await w.createPage({ title: 'Source', content: '[[Target]]' })
          const backlinks = w.getBacklinks('target')
          if (backlinks.length !== 1 || backlinks[0] !== 'source') {
            throw new Error(`Expected backlink from 'source', got: ${backlinks.join(', ')}`)
          }
        }
      },
      {
        name: 'updates backlinks when page content changes',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Target' })
          const source = await w.createPage({ title: 'Source', content: '[[Target]]' })

          let backlinks = w.getBacklinks('target')
          if (backlinks.length !== 1) throw new Error('Backlink not created')

          await w.updatePage(source.id, { content: 'No links' })
          backlinks = w.getBacklinks('target')
          if (backlinks.length !== 0) throw new Error('Backlink not removed')
        }
      },
      {
        name: 'returns linked page objects with getLinkedPages',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Target' })
          const source = await w.createPage({ title: 'Source', content: '[[Target]]' })
          const linked = w.getLinkedPages(source.id)
          if (linked.length !== 1 || linked[0].title !== 'Target') {
            throw new Error('getLinkedPages failed')
          }
        }
      },

      // === Page Retrieval ===
      {
        name: 'getPage returns page by id',
        fn: async () => {
          const w = createWiki()
          const created = await w.createPage({ title: 'Test' })
          const retrieved = w.getPage(created.id)
          if (!retrieved || retrieved.id !== created.id) {
            throw new Error('getPage failed')
          }
        }
      },
      {
        name: 'getPage returns undefined for non-existent id',
        fn: async () => {
          const w = createWiki()
          const page = w.getPage('nonexistent')
          if (page !== undefined) throw new Error('Should return undefined')
        }
      },
      {
        name: 'getPageByTitle returns page by exact title',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Exact Title' })
          const page = w.getPageByTitle('Exact Title')
          if (!page || page.title !== 'Exact Title') throw new Error('getPageByTitle failed')
        }
      },
      {
        name: 'getPageByTitle with ignoreCase option',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Test Page' })
          const page = w.getPageByTitle('test page', { ignoreCase: true })
          if (!page || page.title !== 'Test Page') {
            throw new Error('ignoreCase option failed')
          }
        }
      },

      // === Page Updates ===
      {
        name: 'updatePage updates specified fields',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Original', content: 'Old' })
          const updated = await w.updatePage(page.id, { content: 'New' })
          if (updated.content !== 'New') throw new Error('Content not updated')
          if (updated.title !== 'Original') throw new Error('Title should not change')
        }
      },
      {
        name: 'updatePage updates modified timestamp',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Test' })
          await new Promise(resolve => setTimeout(resolve, 10))
          const updated = await w.updatePage(page.id, { content: 'New' })
          if (updated.modified.getTime() <= page.modified.getTime()) {
            throw new Error('Modified timestamp not updated')
          }
        }
      },
      {
        name: 'updatePage throws Error for non-existent page',
        fn: async () => {
          const w = createWiki()
          try {
            await w.updatePage('nonexistent', { content: 'New' })
            throw new Error('Should have thrown Error')
          } catch (e) {
            if (!e.message.includes('not found')) {
              throw new Error(`Expected 'not found' error, got: ${e.message}`)
            }
          }
        }
      },

      // === Page Deletion ===
      {
        name: 'deletePage removes page from wiki',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'To Delete' })
          await w.deletePage(page.id)
          const retrieved = w.getPage(page.id)
          if (retrieved !== undefined) throw new Error('Page still exists')
        }
      },
      {
        name: 'deletePage creates dead links',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Target' })
          await w.createPage({ title: 'Source', content: '[[Target]]' })
          await w.deletePage('target')
          const deadLinks = w.getDeadLinks()
          if (deadLinks.length !== 1) {
            throw new Error(`Expected 1 dead link, got ${deadLinks.length}`)
          }
        }
      },

      // === Link Resolution ===
      {
        name: 'resolveLink normalizes to page id',
        fn: async () => {
          const w = createWiki()
          const id1 = w.resolveLink('Kingdom of Aldoria')
          const id2 = w.resolveLink('kingdom of aldoria')
          const id3 = w.resolveLink('KINGDOM OF ALDORIA')
          if (id1 !== 'kingdom-of-aldoria' || id2 !== 'kingdom-of-aldoria' || id3 !== 'kingdom-of-aldoria') {
            throw new Error('resolveLink not case-insensitive')
          }
        }
      },
      {
        name: 'resolveLinkToPage returns page if exists',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Kingdom of Aldoria' })
          const page = w.resolveLinkToPage('Kingdom of Aldoria')
          if (!page || page.id !== 'kingdom-of-aldoria') {
            throw new Error('resolveLinkToPage failed')
          }
        }
      },

      // === Dead Links & Orphans ===
      {
        name: 'getDeadLinks finds links to non-existent pages',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Source', content: '[[Nonexistent]]' })
          const deadLinks = w.getDeadLinks()
          if (deadLinks.length !== 1) {
            throw new Error(`Expected 1 dead link, got ${deadLinks.length}`)
          }
          if (deadLinks[0].target !== 'Nonexistent') {
            throw new Error(`Expected target 'Nonexistent', got '${deadLinks[0].target}'`)
          }
        }
      },
      {
        name: 'getOrphans finds pages with no backlinks',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Orphan' })
          await w.createPage({ title: 'Linked' })
          await w.createPage({ title: 'Linker', content: '[[Linked]]' })
          const orphans = w.getOrphans()
          const orphanIds = orphans.map(p => p.id)
          if (!orphanIds.includes('orphan')) throw new Error('Missing orphan')
          if (orphanIds.includes('linked')) throw new Error('Linked page should not be orphan')
        }
      },
      {
        name: 'self-referential link prevents orphan status',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Self', content: '[[Self]]' })
          const orphans = w.getOrphans()
          if (orphans.length > 0) throw new Error('Self-linked page is orphan')
        }
      },

      // === Graph Operations ===
      {
        name: 'getGraph returns adjacency list',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'A', content: '[[B]]' })
          await w.createPage({ title: 'B' })
          const graph = w.getGraph()
          if (!graph['a'] || !graph['a'].includes('b')) {
            throw new Error('Graph structure incorrect')
          }
        }
      },
      {
        name: 'getConnectedPages traverses graph',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'A', content: '[[B]]' })
          await w.createPage({ title: 'B', content: '[[C]]' })
          await w.createPage({ title: 'C' })
          const connected = w.getConnectedPages('a', 2)
          if (connected.length !== 3) {
            throw new Error(`Expected 3 connected pages, got ${connected.length}`)
          }
        }
      },
      {
        name: 'getConnectedPages handles cycles',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'A', content: '[[B]]' })
          await w.createPage({ title: 'B', content: '[[C]]' })
          await w.createPage({ title: 'C', content: '[[A]]' })
          const connected = w.getConnectedPages('a', 10)
          if (connected.length !== 3) {
            throw new Error('Cycle handling failed - infinite loop or wrong count')
          }
        }
      },

      // === Search ===
      {
        name: 'search finds pages by title',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Magic Sword' })
          await w.createPage({ title: 'Other' })
          const results = w.search('magic')
          if (results.length !== 1 || results[0].title !== 'Magic Sword') {
            throw new Error('Search by title failed')
          }
        }
      },
      {
        name: 'search is case-insensitive',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Test Page' })
          const results = w.search('test')
          if (results.length !== 1) throw new Error('Case-insensitive search failed')
        }
      },
      {
        name: 'search with fields option',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Title Match', content: 'different' })
          await w.createPage({ title: 'Different', content: 'Title Match' })
          const titleResults = w.search('Title Match', { fields: ['title'] })
          if (titleResults.length !== 1 || titleResults[0].title !== 'Title Match') {
            throw new Error('Search fields option failed')
          }
        }
      },

      // === List & Filter ===
      {
        name: 'listPages returns all pages',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Page 1' })
          await w.createPage({ title: 'Page 2' })
          const pages = w.listPages()
          if (pages.length !== 2) throw new Error(`Expected 2 pages, got ${pages.length}`)
        }
      },
      {
        name: 'listPages filters by type',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Person', type: 'person' })
          await w.createPage({ title: 'Place', type: 'place' })
          const people = w.listPages({ type: 'person' })
          if (people.length !== 1 || people[0].title !== 'Person') {
            throw new Error('Type filter failed')
          }
        }
      },
      {
        name: 'listPages filters by tags',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Tagged', tags: ['important'] })
          await w.createPage({ title: 'Untagged' })
          const tagged = w.listPages({ tags: ['important'] })
          if (tagged.length !== 1 || tagged[0].title !== 'Tagged') {
            throw new Error('Tag filter failed')
          }
        }
      },
      {
        name: 'listPages sorts pages',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'B Page' })
          await new Promise(resolve => setTimeout(resolve, 10))
          await w.createPage({ title: 'A Page' })
          const byTitle = w.listPages({ sort: 'title', order: 'asc' })
          if (byTitle[0].title !== 'A Page' || byTitle[1].title !== 'B Page') {
            throw new Error('Sort by title failed')
          }
        }
      },

      // === Import/Export ===
      {
        name: 'export returns array of pages',
        fn: async () => {
          const w = createWiki()
          await w.createPage({ title: 'Test' })
          const exported = w.export()
          if (!Array.isArray(exported) || exported.length !== 1) {
            throw new Error('Export failed')
          }
        }
      },
      {
        name: 'import loads pages',
        fn: async () => {
          const w = createWiki()
          const data = [{
            id: 'test',
            title: 'Test',
            content: '',
            created: new Date().toISOString(),
            modified: new Date().toISOString()
          }]
          const count = await w.import(data, { mode: 'replace' })
          if (count !== 1) throw new Error('Import count wrong')
          const page = w.getPage('test')
          if (!page) throw new Error('Imported page not found')
        }
      },
      {
        name: 'import rebuilds link indexes',
        fn: async () => {
          const w = createWiki()
          const data = [
            {
              id: 'a',
              title: 'A',
              content: '[[B]]',
              created: new Date().toISOString(),
              modified: new Date().toISOString()
            },
            {
              id: 'b',
              title: 'B',
              content: '',
              created: new Date().toISOString(),
              modified: new Date().toISOString()
            }
          ]
          await w.import(data, { mode: 'replace' })
          const backlinks = w.getBacklinks('b')
          if (backlinks.length !== 1 || backlinks[0] !== 'a') {
            throw new Error('Import did not rebuild indexes')
          }
        }
      },

      // === Events ===
      {
        name: 'fires create event',
        fn: async () => {
          const w = createWiki()
          let eventFired = false
          w.on('create', () => { eventFired = true })
          await w.createPage({ title: 'Test' })
          if (!eventFired) throw new Error('Create event not fired')
        }
      },
      {
        name: 'fires update event',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Test' })
          let eventFired = false
          w.on('update', () => { eventFired = true })
          await w.updatePage(page.id, { content: 'New' })
          if (!eventFired) throw new Error('Update event not fired')
        }
      },
      {
        name: 'fires delete event',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Test' })
          let eventFired = false
          w.on('delete', () => { eventFired = true })
          await w.deletePage(page.id)
          if (!eventFired) throw new Error('Delete event not fired')
        }
      },
      {
        name: 'unsubscribe stops callbacks',
        fn: async () => {
          const w = createWiki()
          let count = 0
          const unsubscribe = w.on('create', () => { count++ })
          await w.createPage({ title: 'Test 1' })
          unsubscribe()
          await w.createPage({ title: 'Test 2' })
          if (count !== 1) throw new Error(`Expected 1 event, got ${count}`)
        }
      },

      // === Edge Cases ===
      {
        name: 'handles unicode in titles',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà' })
          if (!page.id) throw new Error('Unicode title failed')
          const retrieved = w.getPageByTitle('Êó•Êú¨Ë™û„ÉÜ„Çπ„Éà')
          if (!retrieved) throw new Error('Unicode retrieval failed')
        }
      },
      {
        name: 'handles special characters in titles',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: "The \"Great\" War" })
          if (page.title !== "The \"Great\" War") throw new Error('Special chars not preserved')
        }
      },
      {
        name: 'handles empty content',
        fn: async () => {
          const w = createWiki()
          const page = await w.createPage({ title: 'Empty', content: '' })
          if (page.content !== '') throw new Error('Empty content failed')
        }
      },
      {
        name: 'handles very long link text',
        fn: async () => {
          const w = createWiki()
          const longText = 'A'.repeat(1000)
          const page = await w.createPage({
            title: 'Test',
            content: `[[${longText}]]`
          })
          const links = w.getLinks(page.id)
          if (links.length !== 1 || links[0] !== longText) {
            throw new Error('Long link text failed')
          }
        }
      }
    ]

    // Test runner implementation
    let testResults = []
    let isRunning = false

    window.runAllTests = async function() {
      if (isRunning) {
        alert('Tests are already running!')
        return
      }

      isRunning = true
      testResults = []

      const output = document.getElementById('testOutput')
      const summary = document.getElementById('summary')
      const progressBar = document.getElementById('progressBar')
      const progressFill = document.getElementById('progressFill')

      output.textContent = ''
      summary.textContent = ''
      summary.className = 'summary'
      progressBar.style.display = 'block'

      let passed = 0
      let failed = 0

      for (let i = 0; i < tests.length; i++) {
        const test = tests[i]
        const progress = Math.round(((i + 1) / tests.length) * 100)
        progressFill.style.width = progress + '%'
        progressFill.textContent = `${i + 1}/${tests.length} tests (${progress}%)`

        try {
          await test.fn()
          passed++
          logTestResult(test.name, 'PASS', null)
        } catch (e) {
          failed++
          logTestResult(test.name, 'FAIL', e.message)
        }

        // Small delay to show progress
        await new Promise(resolve => setTimeout(resolve, 10))
      }

      progressBar.style.display = 'none'

      const total = passed + failed
      const summaryText = `\n${'='.repeat(60)}\nTest Summary: ${passed}/${total} passed${failed > 0 ? `, ${failed} FAILED` : ''}\n${'='.repeat(60)}`
      output.textContent += summaryText

      summary.textContent = `${passed}/${total} tests passed`
      summary.className = failed === 0 ? 'summary all-pass' : 'summary has-fail'

      isRunning = false

      // Auto-scroll to summary
      summary.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
    }

    function logTestResult(name, status, error) {
      const output = document.getElementById('testOutput')
      const prefix = status === 'PASS' ? '‚úì' : '‚úó'
      const statusClass = status === 'PASS' ? 'test-pass' : 'test-fail'

      let line = `${prefix} ${name}`
      if (error) {
        line += `\n  Error: ${error}`
      }

      output.textContent += line + '\n'
      output.scrollTop = output.scrollHeight
    }

    window.clearResults = function() {
      document.getElementById('testOutput').textContent = ''
      document.getElementById('summary').textContent = ''
      document.getElementById('summary').className = 'summary'
      document.getElementById('progressBar').style.display = 'none'
    }

    // Subscribe to events for manual exploration
    wiki.on('create', event => logEvent('create', `Created: ${event.page.title}`))
    wiki.on('update', event => logEvent('update', `Updated: ${event.page.title}`))
    wiki.on('delete', event => logEvent('delete', `Deleted: ${event.page.title}`))
    wiki.on('rename', event => logEvent('rename', `Renamed: ${event.previousTitle} ‚Üí ${event.page.title}`))

    // Helper functions for manual interaction
    function showMessage(elementId, message, isError = false) {
      const el = document.getElementById(elementId)
      el.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`
    }

    function logEvent(type, message) {
      const log = document.getElementById('eventLog')
      const item = document.createElement('div')
      item.className = `event-item ${type}`
      item.innerHTML = `
        <span class="event-time">${new Date().toLocaleTimeString()}</span>
        <strong>${type.toUpperCase()}</strong>: ${message}
      `
      log.insertBefore(item, log.firstChild)
      updateStats()
    }

    function updateStats() {
      const pages = wiki.listPages()
      const deadLinks = wiki.getDeadLinks()
      const orphans = wiki.getOrphans()
      const graph = wiki.getGraph()
      const totalLinks = Object.values(graph).reduce((sum, links) => sum + links.length, 0)

      document.getElementById('statPages').textContent = pages.length
      document.getElementById('statLinks').textContent = totalLinks
      document.getElementById('statOrphans').textContent = orphans.length
      document.getElementById('statDeadLinks').textContent = deadLinks.length

      updateFilterOptions()
    }

    function updateFilterOptions() {
      const types = wiki.getTypes()
      const tags = wiki.getTags()

      const typeSelect = document.getElementById('filterType')
      const currentType = typeSelect.value
      typeSelect.innerHTML = '<option value="">All Types</option>' +
        types.map(t => `<option value="${t}" ${t === currentType ? 'selected' : ''}>${t}</option>`).join('')

      const tagSelect = document.getElementById('filterTags')
      const currentTag = tagSelect.value
      tagSelect.innerHTML = '<option value="">All Tags</option>' +
        tags.map(t => `<option value="${t}" ${t === currentTag ? 'selected' : ''}>${t}</option>`).join('')
    }

    function renderPage(page) {
      const contentWithLinks = page.content.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (match, target, display) => {
        const id = wiki.resolveLink(target)
        const exists = wiki.getPage(id)
        const text = display || target
        return exists
          ? `<span class="wiki-link" onclick="viewPage('${id}')">${text}</span>`
          : `<span class="dead-link">${text}</span>`
      })

      return `
        <div class="page-card">
          <h4>${page.title}</h4>
          <div class="page-id">ID: ${page.id}</div>
          ${page.type ? `<span class="type-badge">${page.type}</span>` : ''}
          ${page.tags ? page.tags.map(t => `<span class="tag">${t}</span>`).join('') : ''}
          <div class="page-content">${contentWithLinks || '<em>No content</em>'}</div>
          <div class="page-meta">
            <span>Created: ${page.created.toLocaleString()}</span>
            <span>Modified: ${page.modified.toLocaleString()}</span>
          </div>
        </div>
      `
    }

    // Manual interaction functions
    window.createPage = async function() {
      try {
        const title = document.getElementById('pageTitle').value
        const content = document.getElementById('pageContent').value
        const type = document.getElementById('pageType').value || undefined
        const tagsStr = document.getElementById('pageTags').value
        const tags = tagsStr ? tagsStr.split(',').map(t => t.trim()).filter(Boolean) : undefined

        if (!title) {
          showMessage('createOutput', 'Please enter a page title', true)
          return
        }

        const page = await wiki.createPage({ title, content, type, tags })
        showMessage('createOutput', `Page "${page.title}" created successfully! (ID: ${page.id})`)
        clearForm()
        refreshPagesList()
      } catch (error) {
        showMessage('createOutput', `Error: ${error.message}`, true)
      }
    }

    window.clearForm = function() {
      document.getElementById('pageTitle').value = ''
      document.getElementById('pageContent').value = ''
      document.getElementById('pageType').value = ''
      document.getElementById('pageTags').value = ''
    }

    window.getPageById = function() {
      const id = document.getElementById('getPageId').value
      const page = wiki.getPage(id)
      const output = document.getElementById('getPageOutput')

      if (page) {
        output.innerHTML = renderPage(page)
        output.classList.remove('empty')
      } else {
        output.innerHTML = '<div class="error-message">Page not found</div>'
      }
    }

    window.getPageByTitle = function(ignoreCase) {
      const title = document.getElementById('getPageTitle').value
      const page = wiki.getPageByTitle(title, { ignoreCase })
      const output = document.getElementById('getPageOutput')

      if (page) {
        output.innerHTML = renderPage(page)
        output.classList.remove('empty')
      } else {
        output.innerHTML = '<div class="error-message">Page not found</div>'
      }
    }

    window.viewPage = function(id) {
      document.getElementById('getPageId').value = id
      getPageById()
      document.getElementById('getPageId').scrollIntoView({ behavior: 'smooth', block: 'center' })
    }

    window.updatePage = async function() {
      try {
        const id = document.getElementById('updatePageId').value
        const content = document.getElementById('updateContent').value

        if (!id) {
          showMessage('updateOutput', 'Please enter a page ID', true)
          return
        }

        const page = await wiki.updatePage(id, { content })
        showMessage('updateOutput', `Page "${page.title}" updated successfully!`)
        refreshPagesList()
      } catch (error) {
        showMessage('updateOutput', `Error: ${error.message}`, true)
      }
    }

    window.loadPageForUpdate = function() {
      const id = document.getElementById('updatePageId').value
      const page = wiki.getPage(id)

      if (page) {
        document.getElementById('updateContent').value = page.content
        showMessage('updateOutput', `Loaded page "${page.title}"`)
      } else {
        showMessage('updateOutput', 'Page not found', true)
      }
    }

    window.renamePage = async function(updateId) {
      try {
        const id = document.getElementById('renamePageId').value
        const newTitle = document.getElementById('renameNewTitle').value

        if (!id || !newTitle) {
          showMessage('renameOutput', 'Please enter both page ID and new title', true)
          return
        }

        const page = await wiki.renamePage(id, newTitle, { updateId })
        showMessage('renameOutput', `Page renamed to "${page.title}"${updateId ? ` (new ID: ${page.id})` : ''}`)
        refreshPagesList()
      } catch (error) {
        showMessage('renameOutput', `Error: ${error.message}`, true)
      }
    }

    window.deletePage = async function() {
      try {
        const id = document.getElementById('deletePageId').value

        if (!id) {
          showMessage('deleteOutput', 'Please enter a page ID', true)
          return
        }

        if (!confirm(`Are you sure you want to delete page "${id}"?`)) {
          return
        }

        await wiki.deletePage(id)
        showMessage('deleteOutput', `Page "${id}" deleted successfully!`)
        refreshPagesList()
      } catch (error) {
        showMessage('deleteOutput', `Error: ${error.message}`, true)
      }
    }

    window.refreshPagesList = function() {
      const filterType = document.getElementById('filterType').value
      const filterTag = document.getElementById('filterTags').value
      const sortBy = document.getElementById('sortBy').value

      const options = {}
      if (filterType) options.type = filterType
      if (filterTag) options.tags = [filterTag]
      options.sort = sortBy.split(' ')[0]
      options.order = sortBy.includes('newest') ? 'desc' : 'asc'

      const pages = wiki.listPages(options)
      const output = document.getElementById('pagesList')

      if (pages.length === 0) {
        output.innerHTML = '<div style="color: #999; font-style: italic;">No pages match the filter</div>'
        output.classList.add('empty')
      } else {
        output.innerHTML = pages.map(renderPage).join('')
        output.classList.remove('empty')
      }
    }

    window.showLinks = function() {
      const id = document.getElementById('linksPageId').value
      const output = document.getElementById('linksOutput')

      if (!id) {
        output.innerHTML = '<div class="error-message">Please enter a page ID</div>'
        return
      }

      const page = wiki.getPage(id)
      if (!page) {
        output.innerHTML = '<div class="error-message">Page not found</div>'
        return
      }

      const outgoing = wiki.getLinks(id)
      const incoming = wiki.getBacklinks(id)
      const outgoingPages = wiki.getLinkedPages(id)
      const incomingPages = wiki.getBacklinkPages(id)

      output.innerHTML = `
        <h4>${page.title}</h4>
        <h5 style="margin-top: 15px;">Outgoing Links (${outgoing.length}):</h5>
        ${outgoing.length > 0 ? `
          <ul class="link-list">
            ${outgoing.map(link => {
              const linkedPage = wiki.resolveLinkToPage(link)
              return `<li>
                ${linkedPage
                  ? `<span class="wiki-link" onclick="viewPage('${linkedPage.id}')">${link}</span>`
                  : `<span class="dead-link">${link}</span> (dead link)`
                }
              </li>`
            }).join('')}
          </ul>
        ` : '<p><em>No outgoing links</em></p>'}

        <h5 style="margin-top: 15px;">Incoming Links / Backlinks (${incoming.length}):</h5>
        ${incoming.length > 0 ? `
          <ul class="link-list">
            ${incomingPages.map(p => `
              <li>
                <span class="wiki-link" onclick="viewPage('${p.id}')">${p.title}</span>
                <span style="color: #999; font-size: 0.85em;"> (${p.id})</span>
              </li>
            `).join('')}
          </ul>
        ` : '<p><em>No incoming links</em></p>'}
      `
      output.classList.remove('empty')
    }

    window.showConnectedPages = function() {
      const id = document.getElementById('graphStartId').value
      const depth = parseInt(document.getElementById('graphDepth').value)
      const output = document.getElementById('graphOutput')

      if (!id) {
        output.innerHTML = '<div class="error-message">Please enter a page ID</div>'
        return
      }

      const connected = wiki.getConnectedPages(id, depth)

      output.innerHTML = `
        <h4>Pages within ${depth} link${depth !== 1 ? 's' : ''} of "${id}":</h4>
        <p style="margin: 10px 0; color: #666;">Found ${connected.length} page${connected.length !== 1 ? 's' : ''}</p>
        ${connected.map(renderPage).join('')}
      `
      output.classList.remove('empty')
    }

    window.showFullGraph = function() {
      const graph = wiki.getGraph()
      const output = document.getElementById('graphOutput')

      const graphViz = Object.entries(graph)
        .map(([id, targets]) => {
          const page = wiki.getPage(id)
          const title = page ? page.title : id
          return `${title} (${id}):\n  ‚Üí ${targets.length > 0 ? targets.join(', ') : '(no links)'}`
        })
        .join('\n\n')

      output.innerHTML = `
        <h4>Complete Link Graph:</h4>
        <div class="graph-viz">${graphViz || '<em>Empty graph</em>'}</div>
      `
      output.classList.remove('empty')
    }

    window.searchWiki = function() {
      const query = document.getElementById('searchQuery').value
      const output = document.getElementById('searchOutput')

      if (!query) {
        output.innerHTML = '<div class="error-message">Please enter a search query</div>'
        return
      }

      const fields = []
      if (document.getElementById('searchTitle').checked) fields.push('title')
      if (document.getElementById('searchContent').checked) fields.push('content')
      if (document.getElementById('searchTags').checked) fields.push('tags')

      const results = wiki.search(query, { fields })

      if (results.length === 0) {
        output.innerHTML = `<div style="color: #999; font-style: italic;">No results found for "${query}"</div>`
      } else {
        output.innerHTML = `
          <h4>Found ${results.length} result${results.length !== 1 ? 's' : ''} for "${query}":</h4>
          ${results.map(renderPage).join('')}
        `
      }
      output.classList.remove('empty')
    }

    window.showDeadLinks = function() {
      const deadLinks = wiki.getDeadLinks()
      const output = document.getElementById('deadLinksOutput')

      if (deadLinks.length === 0) {
        output.innerHTML = '<div style="color: #27ae60; font-weight: 500;">‚úì No dead links! All links point to existing pages.</div>'
      } else {
        const grouped = {}
        deadLinks.forEach(dl => {
          if (!grouped[dl.source]) grouped[dl.source] = []
          grouped[dl.source].push(dl.target)
        })

        output.innerHTML = `
          <h4>Dead Links (${deadLinks.length}):</h4>
          ${Object.entries(grouped).map(([source, targets]) => {
            const page = wiki.getPage(source)
            return `
              <div style="margin-bottom: 15px;">
                <strong>${page ? page.title : source}</strong> (${source}):
                <ul class="link-list" style="margin-top: 5px;">
                  ${targets.map(t => `<li><span class="dead-link">${t}</span></li>`).join('')}
                </ul>
              </div>
            `
          }).join('')}
        `
      }
      output.classList.remove('empty')
    }

    window.showOrphans = function() {
      const orphans = wiki.getOrphans()
      const output = document.getElementById('deadLinksOutput')

      if (orphans.length === 0) {
        output.innerHTML = '<div style="color: #27ae60; font-weight: 500;">‚úì No orphan pages! All pages have incoming links.</div>'
      } else {
        output.innerHTML = `
          <h4>Orphan Pages (${orphans.length}):</h4>
          <p style="color: #666; margin-bottom: 15px;">Pages with no incoming links</p>
          ${orphans.map(renderPage).join('')}
        `
      }
      output.classList.remove('empty')
    }

    window.exportWiki = function() {
      const data = wiki.export()
      const json = JSON.stringify(data, null, 2)
      const output = document.getElementById('exportOutput')

      navigator.clipboard.writeText(json).then(() => {
        output.innerHTML = `
          <div class="success-message">
            Exported ${data.length} pages to clipboard!
          </div>
          <details style="margin-top: 10px;">
            <summary style="cursor: pointer; color: #3498db;">View JSON</summary>
            <pre>${json}</pre>
          </details>
        `
      }).catch(err => {
        output.innerHTML = `
          <div class="error-message">Failed to copy to clipboard</div>
          <pre>${json}</pre>
        `
      })
      output.classList.remove('empty')
    }

    window.importFromClipboard = async function() {
      try {
        const json = await navigator.clipboard.readText()
        const data = JSON.parse(json)
        const mode = document.getElementById('importMode').value
        const count = await wiki.import(data, { mode })

        const output = document.getElementById('exportOutput')
        output.innerHTML = `
          <div class="success-message">
            Successfully imported ${count} pages in "${mode}" mode!
          </div>
        `
        output.classList.remove('empty')
        refreshPagesList()
      } catch (error) {
        const output = document.getElementById('exportOutput')
        output.innerHTML = `<div class="error-message">Import failed: ${error.message}</div>`
      }
    }

    window.clearEvents = function() {
      document.getElementById('eventLog').innerHTML = '<div style="color: #999; font-style: italic;">Events cleared...</div>'
    }

    window.loadExampleData = async function() {
      if (wiki.listPages().length > 0) {
        if (!confirm('This will clear the current wiki and load example data. Continue?')) {
          return
        }
      }

      try {
        await wiki.import([], { mode: 'replace' })

        await wiki.createPage({
          title: 'Kingdom of Aldoria',
          content: `A prosperous kingdom in the eastern valleys.

Founded by [[King Aldric I]] after the [[Battle of Five Rivers]].

## Notable Locations
- [[Castle Aldric]] - The royal seat
- [[Port Valen]] - Major trading hub

## Culture
Known for its [[School of Magic]] and annual [[Harvest Festival]].`,
          type: 'place',
          tags: ['nation', 'important']
        })

        await wiki.createPage({
          title: 'King Aldric I',
          content: `First ruler of the [[Kingdom of Aldoria]].

Born in 1245, died 1312. Led the armies at the [[Battle of Five Rivers]] and established the kingdom in 1270.

His legacy includes:
- Founded [[Castle Aldric]]
- Established the [[School of Magic]]
- Created the Royal Charter`,
          type: 'person',
          tags: ['royalty', 'historical', 'founder']
        })

        await wiki.createPage({
          title: 'Battle of Five Rivers',
          content: `Decisive battle in 1270 where [[King Aldric I]] unified the valley kingdoms.

Fought at the confluence of five rivers, this three-day battle resulted in the formation of the [[Kingdom of Aldoria]].

Key figures:
- [[King Aldric I]] (victor)
- General Marcus (Aldric's general)
- The opposing warlords`,
          type: 'event',
          tags: ['historical', 'military', 'important']
        })

        await wiki.createPage({
          title: 'School of Magic',
          content: `Premier institution for magical education in [[Kingdom of Aldoria]].

Founded by [[King Aldric I]] in 1275. Located near [[Castle Aldric]].

The school teaches various disciplines including elemental magic, healing, and enchantment.

Notable alumni include the [[Archmage Elara]].`,
          type: 'organization',
          tags: ['magic', 'education']
        })

        await wiki.createPage({
          title: 'Castle Aldric',
          content: `Royal palace of the [[Kingdom of Aldoria]].

Built between 1270-1280 under [[King Aldric I]]. Features impressive fortifications and the famous Crystal Throne Room.

Home to the royal family and seat of government. The [[School of Magic]] is located nearby.`,
          type: 'place',
          tags: ['architecture', 'important']
        })

        await wiki.createPage({
          title: 'Forgotten Ruins',
          content: `Ancient ruins in the northern wilderness. Their origin and purpose remain unknown.

Local legends speak of a civilization that predates the [[Kingdom of Aldoria]] by thousands of years.`,
          type: 'place',
          tags: ['mysterious', 'ancient']
        })

        showMessage('createOutput', '‚úì Example wiki loaded! 6 pages created with interconnected links.')
        refreshPagesList()
      } catch (error) {
        showMessage('createOutput', `Error loading example data: ${error.message}`, true)
      }
    }

    // Initialize
    updateStats()
    refreshPagesList()
  </script>
</body>
</html>
