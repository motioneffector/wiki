<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/wiki - Demo</title>
  <style>
/* ============================================
   RESET & BASE
   ============================================ */

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
  font-size: 1rem;
  line-height: 1.5;
  color: #e6edf3;
  background: #0d1117;
  min-height: 100vh;
}

/* ============================================
   CSS VARIABLES
   ============================================ */

:root {
  /* Backgrounds */
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-tertiary: #21262d;
  --bg-hover: #30363d;

  /* Borders */
  --border-default: #30363d;
  --border-muted: #21262d;

  /* Text */
  --text-primary: #e6edf3;
  --text-secondary: #8b949e;
  --text-muted: #6e7681;
  --text-link: #58a6ff;

  /* Accents */
  --accent-blue: #1f6feb;
  --accent-blue-hover: #388bfd;
  --accent-green: #238636;
  --accent-green-bright: #3fb950;
  --accent-red: #da3633;
  --accent-red-bright: #f85149;
  --accent-yellow: #d29922;
  --accent-yellow-bright: #e3b341;
  --accent-purple: #8957e5;

  /* Spacing */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;
  --space-xxl: 48px;

  /* Radii */
  --radius-sm: 4px;
  --radius-md: 6px;
  --radius-lg: 8px;
  --radius-xl: 12px;

  /* Typography */
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
  --font-size-xxl: 2rem;

  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.4);

  /* Transitions */
  --transition-fast: 0.1s ease;
  --transition-normal: 0.2s ease;
  --transition-slow: 0.3s ease;
}

/* ============================================
   LAYOUT
   ============================================ */

.page {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--space-xl);
}

/* ============================================
   HEADER
   ============================================ */

.header {
  margin-bottom: var(--space-xxl);
  padding-bottom: var(--space-xl);
  border-bottom: 1px solid var(--border-default);
}

.header-title {
  font-size: var(--font-size-xxl);
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-sm);
}

.header-description {
  font-size: var(--font-size-lg);
  color: var(--text-secondary);
  margin-bottom: var(--space-lg);
}

.header-links {
  display: flex;
  gap: var(--space-md);
}

.header-link {
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
  color: var(--text-link);
  text-decoration: none;
  font-size: var(--font-size-sm);
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--radius-md);
  transition: background var(--transition-fast);
}

.header-link:hover {
  background: var(--bg-tertiary);
  text-decoration: underline;
}

/* ============================================
   EXHIBITS
   ============================================ */

.exhibits {
  display: flex;
  flex-direction: column;
  gap: var(--space-xxl);
}

.exhibit {
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-xl);
  overflow: hidden;
}

.exhibit-header {
  padding: var(--space-lg);
  border-bottom: 1px solid var(--border-default);
}

.exhibit-title {
  font-size: var(--font-size-xl);
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-xs);
}

.exhibit-description {
  font-size: var(--font-size-md);
  color: var(--text-secondary);
}

.exhibit-content {
  padding: var(--space-lg);
}

.exhibit-interactive {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-lg);
  min-height: 200px;
  padding: var(--space-lg);
  margin-bottom: var(--space-lg);
}

.exhibit-controls {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-lg);
}

.exhibit-state {
  padding: var(--space-md);
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.exhibit-state-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: var(--space-sm);
}

/* ============================================
   BUTTONS
   ============================================ */

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-xs);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--font-size-sm);
  font-weight: 500;
  border-radius: var(--radius-md);
  border: 1px solid transparent;
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: var(--accent-blue);
  color: white;
  border-color: var(--accent-blue);
}

.btn-primary:hover:not(:disabled) {
  background: var(--accent-blue-hover);
  border-color: var(--accent-blue-hover);
}

.btn-secondary {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border-color: var(--border-default);
}

.btn-secondary:hover:not(:disabled) {
  background: var(--bg-hover);
}

.btn-danger {
  background: var(--accent-red);
  color: white;
  border-color: var(--accent-red);
}

.btn-danger:hover:not(:disabled) {
  background: var(--accent-red-bright);
}

.btn-success {
  background: var(--accent-green);
  color: white;
  border-color: var(--accent-green);
}

.btn-success:hover:not(:disabled) {
  background: var(--accent-green-bright);
}

.btn-small {
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
}

/* ============================================
   INPUTS
   ============================================ */

.input {
  background: var(--bg-primary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--font-size-sm);
  color: var(--text-primary);
  transition: border-color var(--transition-fast);
}

.input:focus {
  outline: none;
  border-color: var(--accent-blue);
}

.input::placeholder {
  color: var(--text-muted);
}

.input-mono {
  font-family: var(--font-mono);
}

select.input {
  cursor: pointer;
}

textarea.input {
  resize: vertical;
  min-height: 80px;
  font-family: inherit;
}

/* ============================================
   TOGGLE
   ============================================ */

.toggle {
  display: inline-flex;
  align-items: center;
  gap: var(--space-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
}

.toggle-switch {
  position: relative;
  width: 40px;
  height: 22px;
  background: var(--bg-hover);
  border-radius: 11px;
  transition: background var(--transition-normal);
}

.toggle-switch::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 3px;
  width: 16px;
  height: 16px;
  background: var(--text-primary);
  border-radius: 50%;
  transition: transform var(--transition-normal);
}

.toggle input {
  display: none;
}

.toggle input:checked + .toggle-switch {
  background: var(--accent-blue);
}

.toggle input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.toggle-label {
  color: var(--text-secondary);
}

/* ============================================
   TAGS / BADGES
   ============================================ */

.tag {
  display: inline-block;
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  font-weight: 500;
  border-radius: var(--radius-sm);
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}

.tag-blue {
  background: rgba(31, 111, 235, 0.2);
  color: var(--accent-blue-hover);
}

.tag-green {
  background: rgba(35, 134, 54, 0.2);
  color: var(--accent-green-bright);
}

.tag-red {
  background: rgba(218, 54, 51, 0.2);
  color: var(--accent-red-bright);
}

.tag-yellow {
  background: rgba(210, 153, 34, 0.2);
  color: var(--accent-yellow-bright);
}

.tag-purple {
  background: rgba(137, 87, 229, 0.2);
  color: var(--accent-purple);
}

/* ============================================
   TEST RUNNER
   ============================================ */

.test-runner {
  margin-top: var(--space-xxl);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-xl);
  overflow: hidden;
}

.test-runner-header {
  padding: var(--space-lg);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.test-runner-title {
  font-size: var(--font-size-xl);
  font-weight: 600;
}

.test-runner-actions {
  display: flex;
  gap: var(--space-sm);
}

.test-runner-content {
  padding: var(--space-lg);
}

.test-progress {
  margin-bottom: var(--space-lg);
}

.test-progress-bar {
  height: 8px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: var(--space-sm);
}

.test-progress-fill {
  height: 100%;
  background: var(--accent-blue);
  border-radius: 4px;
  transition: width var(--transition-fast);
  width: 0%;
}

.test-progress-fill.success {
  background: var(--accent-green);
}

.test-progress-fill.failure {
  background: var(--accent-red);
}

.test-progress-text {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.test-output {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  max-height: 400px;
  overflow-y: auto;
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.test-output-empty {
  padding: var(--space-xl);
  text-align: center;
  color: var(--text-muted);
}

.test-item {
  padding: var(--space-sm) var(--space-md);
  border-bottom: 1px solid var(--border-muted);
  display: flex;
  align-items: flex-start;
  gap: var(--space-sm);
}

.test-item:last-child {
  border-bottom: none;
}

.test-icon {
  flex-shrink: 0;
  font-size: var(--font-size-md);
}

.test-icon.pass {
  color: var(--accent-green-bright);
}

.test-icon.fail {
  color: var(--accent-red-bright);
}

.test-name {
  color: var(--text-primary);
}

.test-error {
  color: var(--accent-red-bright);
  font-size: var(--font-size-xs);
  margin-top: var(--space-xs);
}

.test-summary {
  margin-top: var(--space-lg);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  display: flex;
  gap: var(--space-lg);
}

.test-summary-item {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.test-summary-item.passed {
  color: var(--accent-green-bright);
}

.test-summary-item.failed {
  color: var(--accent-red-bright);
}

.test-summary-item.skipped {
  color: var(--text-muted);
}

/* ============================================
   UTILITY CLASSES
   ============================================ */

.text-primary { color: var(--text-primary); }
.text-secondary { color: var(--text-secondary); }
.text-muted { color: var(--text-muted); }
.text-success { color: var(--accent-green-bright); }
.text-error { color: var(--accent-red-bright); }
.text-warning { color: var(--accent-yellow-bright); }

.font-mono { font-family: var(--font-mono); }

.flex { display: flex; }
.flex-col { flex-direction: column; }
.flex-wrap { flex-wrap: wrap; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.gap-xs { gap: var(--space-xs); }
.gap-sm { gap: var(--space-sm); }
.gap-md { gap: var(--space-md); }
.gap-lg { gap: var(--space-lg); }

.mt-sm { margin-top: var(--space-sm); }
.mt-md { margin-top: var(--space-md); }
.mt-lg { margin-top: var(--space-lg); }
.mb-sm { margin-bottom: var(--space-sm); }
.mb-md { margin-bottom: var(--space-md); }
.mb-lg { margin-bottom: var(--space-lg); }

.p-sm { padding: var(--space-sm); }
.p-md { padding: var(--space-md); }
.p-lg { padding: var(--space-lg); }

.hidden { display: none; }

/* ============================================
   SCROLLBAR
   ============================================ */

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--bg-hover);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-default);
}

/* ============================================
   EXHIBIT 1: LIVING WIKI
   ============================================ */

#wiki-canvas {
  position: relative;
  min-height: 450px;
  overflow: hidden;
}

#wiki-canvas svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

.wiki-card {
  position: absolute;
  width: 140px;
  padding: var(--space-md);
  background: var(--bg-secondary);
  border: 2px solid var(--border-default);
  border-radius: var(--radius-lg);
  cursor: grab;
  z-index: 2;
  transition: border-color var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast);
  user-select: none;
}

.wiki-card:hover {
  border-color: var(--accent-blue);
}

.wiki-card.selected {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.3);
}

.wiki-card.dragging {
  cursor: grabbing;
  z-index: 100;
  box-shadow: var(--shadow-lg);
}

.wiki-card.ghost {
  background: transparent;
  border-style: dashed;
  border-color: var(--text-muted);
  opacity: 0.6;
}

.wiki-card.ghost:hover {
  border-color: var(--accent-yellow);
  opacity: 0.8;
}

.wiki-card.orphan {
  opacity: 0.5;
}

.wiki-card.pulse {
  animation: card-pulse 0.3s ease;
}

@keyframes card-pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.wiki-card-title {
  font-size: var(--font-size-sm);
  font-weight: 600;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: var(--space-xs);
}

.wiki-card-type {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
}

.wiki-card .type-icon {
  margin-right: var(--space-xs);
}

.connection-line {
  stroke: var(--border-default);
  stroke-width: 2;
  fill: none;
  transition: stroke var(--transition-fast), stroke-width var(--transition-fast);
}

.connection-line.highlight {
  stroke: var(--accent-blue);
  stroke-width: 3;
}

.connection-line.dead {
  stroke-dasharray: 6 4;
  stroke: var(--text-muted);
}

.connection-line.incoming {
  stroke: var(--accent-green);
  opacity: 0.6;
}

#wiki-editor {
  margin-top: var(--space-lg);
  padding: var(--space-lg);
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  display: none;
}

#wiki-editor.visible {
  display: block;
}

#wiki-editor-title {
  width: 100%;
  margin-bottom: var(--space-md);
  font-size: var(--font-size-lg);
  font-weight: 600;
}

#wiki-editor-content {
  width: 100%;
  min-height: 100px;
  font-family: var(--font-mono);
  line-height: 1.6;
}

.wiki-link {
  color: var(--text-link);
  cursor: pointer;
  border-radius: 2px;
  transition: background var(--transition-fast);
}

.wiki-link:hover {
  background: rgba(88, 166, 255, 0.2);
}

.wiki-link.dead {
  color: var(--accent-red-bright);
}

/* ============================================
   EXHIBIT 2: GRAPH EXPLORER
   ============================================ */

#graph-canvas {
  position: relative;
  min-height: 400px;
  overflow: hidden;
}

#graph-canvas svg {
  width: 100%;
  height: 400px;
}

.graph-node {
  cursor: grab;
  transition: filter var(--transition-fast);
}

.graph-node:hover {
  filter: brightness(1.2);
}

.graph-node.dragging {
  cursor: grabbing;
}

.graph-node circle {
  transition: r var(--transition-fast), fill var(--transition-fast), stroke var(--transition-fast);
}

.graph-node.selected circle {
  stroke: var(--accent-blue);
  stroke-width: 3;
}

.graph-node.lit circle {
  fill: var(--accent-blue);
}

.graph-node.lit-1 circle { fill: var(--accent-blue); }
.graph-node.lit-2 circle { fill: var(--accent-purple); }
.graph-node.lit-3 circle { fill: var(--accent-green); }

.graph-node text {
  font-size: 10px;
  fill: var(--text-secondary);
  pointer-events: none;
  text-anchor: middle;
}

.graph-edge {
  stroke: var(--border-default);
  stroke-width: 1.5;
  fill: none;
  opacity: 0.6;
}

.graph-edge.highlight {
  stroke: var(--accent-blue);
  stroke-width: 2;
  opacity: 1;
}

#graph-info {
  margin-top: var(--space-md);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
}

.depth-slider {
  display: flex;
  align-items: center;
  gap: var(--space-md);
}

.depth-slider input[type="range"] {
  flex: 1;
  height: 8px;
  -webkit-appearance: none;
  background: var(--bg-hover);
  border-radius: 4px;
  cursor: pointer;
}

.depth-slider input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  background: var(--accent-blue);
  border-radius: 50%;
  cursor: grab;
}

.depth-slider input[type="range"]::-webkit-slider-thumb:active {
  cursor: grabbing;
}

/* ============================================
   EXHIBIT 3: TAG & TYPE WORKSHOP
   ============================================ */

#workshop-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-lg);
  min-height: 400px;
}

.bucket-section {
  display: flex;
  flex-direction: column;
  gap: var(--space-md);
}

.bucket-section-title {
  font-size: var(--font-size-sm);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.bucket {
  background: var(--bg-tertiary);
  border: 2px solid var(--border-default);
  border-radius: var(--radius-lg);
  padding: var(--space-md);
  min-height: 80px;
  transition: border-color var(--transition-fast), background var(--transition-fast);
}

.bucket.drop-target {
  border-color: var(--accent-blue);
  background: rgba(31, 111, 235, 0.1);
}

.bucket-header {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  margin-bottom: var(--space-sm);
  font-size: var(--font-size-sm);
  font-weight: 500;
  color: var(--text-primary);
}

.bucket-chips {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
}

.page-chip {
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
  padding: var(--space-xs) var(--space-sm);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
  color: var(--text-primary);
  cursor: grab;
  user-select: none;
  transition: all var(--transition-fast);
}

.page-chip:hover {
  border-color: var(--accent-blue);
}

.page-chip.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.page-chip.highlight {
  background: rgba(31, 111, 235, 0.3);
  border-color: var(--accent-blue);
  animation: chip-pulse 0.5s ease infinite;
}

@keyframes chip-pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(31, 111, 235, 0.4); }
  50% { box-shadow: 0 0 0 4px rgba(31, 111, 235, 0.2); }
}

.add-bucket-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-sm);
  padding: var(--space-md);
  background: transparent;
  border: 2px dashed var(--border-default);
  border-radius: var(--radius-lg);
  color: var(--text-muted);
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.add-bucket-btn:hover {
  border-color: var(--accent-blue);
  color: var(--text-primary);
}

#workshop-search {
  grid-column: 1 / -1;
  margin-top: var(--space-md);
}

#workshop-search input {
  width: 100%;
}
  </style>
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="header-title">@motioneffector/wiki</h1>
      <p class="header-description">A TypeScript library for creating interconnected knowledge bases with bidirectional linking and graph analysis</p>
      <div class="flex items-center justify-between">
        <nav class="header-links">
          <a href="https://www.npmjs.com/package/@motioneffector/wiki" class="header-link" target="_blank">
            npm
          </a>
          <a href="https://github.com/motioneffector/wiki" class="header-link" target="_blank">
            GitHub
          </a>
          <a href="https://github.com/motioneffector/wiki/wiki" class="header-link" target="_blank">
            Manual
          </a>
        </nav>
        <button class="btn btn-secondary" onclick="location.reload()">Reset Page</button>
      </div>
    </header>

    <main class="exhibits">
      <!-- Exhibit 1: The Living Wiki -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">The Living Wiki</h2>
          <p class="exhibit-description">Pages as cards with visible connection lines. Watch links form as you type [[wikilinks]]. Ghost cards show dead links.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="wiki-canvas">
            <svg id="wiki-connections"></svg>
          </div>
          <div id="wiki-editor">
            <input type="text" id="wiki-editor-title" class="input" placeholder="Page title">
            <textarea id="wiki-editor-content" class="input" placeholder="Page content with [[wikilinks]]"></textarea>
            <div class="flex gap-sm mt-md">
              <button class="btn btn-primary" id="wiki-save-btn">Save</button>
              <button class="btn btn-danger" id="wiki-delete-btn">Delete</button>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" id="wiki-new-btn">New Page</button>
            <button class="btn btn-secondary" id="wiki-arrange-btn">Auto-arrange</button>
            <button class="btn btn-secondary" id="wiki-reset-btn">Reset</button>
          </div>
        </div>
      </section>

      <!-- Exhibit 2: Graph Explorer -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Graph Explorer</h2>
          <p class="exhibit-description">Force-directed physics simulation. Drag nodes to see connections react. Explore page neighborhoods with the depth slider.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="graph-canvas">
            <svg id="graph-svg"></svg>
          </div>
          <div id="graph-info">
            <div class="depth-slider">
              <span class="text-secondary">Depth:</span>
              <input type="range" id="depth-slider" min="0" max="3" value="1">
              <span id="depth-value" class="tag tag-blue">1</span>
            </div>
            <div class="mt-md">
              <span class="text-secondary">Selected:</span>
              <span id="selected-node" class="text-primary">Kingdom of Valdoria</span>
              <span class="text-muted ml-md" id="connected-count">(4 connected at depth 1)</span>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" id="graph-shake-btn">Shake</button>
            <button class="btn btn-secondary" id="graph-fit-btn">Fit View</button>
            <label class="toggle">
              <input type="checkbox" id="graph-labels-toggle" checked>
              <span class="toggle-switch"></span>
              <span class="toggle-label">Labels</span>
            </label>
          </div>
        </div>
      </section>

      <!-- Exhibit 3: Tag & Type Workshop -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Tag & Type Workshop</h2>
          <p class="exhibit-description">Drag pages into type buckets (exclusive) and tag buckets (multiple). Search highlights matching chips across all buckets.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="workshop-container">
            <div class="bucket-section" id="types-section">
              <div class="bucket-section-title">Types (one per page)</div>
              <div id="type-buckets"></div>
              <button class="add-bucket-btn" id="add-type-btn">+ New Type</button>
            </div>
            <div class="bucket-section" id="tags-section">
              <div class="bucket-section-title">Tags (many per page)</div>
              <div id="tag-buckets"></div>
              <button class="add-bucket-btn" id="add-tag-btn">+ New Tag</button>
            </div>
            <div id="workshop-search">
              <input type="text" class="input" id="workshop-search-input" placeholder="Search pages...">
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" id="workshop-reset-btn">Reset</button>
            <label class="toggle">
              <input type="checkbox" id="workshop-untagged-toggle">
              <span class="toggle-switch"></span>
              <span class="toggle-label">Show Untagged</span>
            </label>
          </div>
        </div>
      </section>
    </main>

    <footer class="test-runner">
      <div class="test-runner-header">
        <h2 class="test-runner-title">Test Suite</h2>
        <div class="test-runner-actions">
          <button class="btn btn-primary" id="run-tests">Run Tests</button>
          <button class="btn btn-secondary" id="run-fuzz" style="display: none;">Run Fuzz Tests</button>
        </div>
      </div>
      <div class="test-runner-content">
        <div class="test-progress">
          <div class="test-progress-bar">
            <div class="test-progress-fill" id="progress-fill"></div>
          </div>
          <div class="test-progress-text" id="progress-text">Ready to run tests</div>
        </div>
        <div class="test-output" id="test-output">
          <div class="test-output-empty">Click "Run Tests" to execute the test suite</div>
        </div>
        <div class="test-summary hidden" id="test-summary">
          <div class="test-summary-item passed">
            <span>&#10003;</span>
            <span id="passed-count">0</span> passed
          </div>
          <div class="test-summary-item failed">
            <span>&#10007;</span>
            <span id="failed-count">0</span> failed
          </div>
          <div class="test-summary-item skipped">
            <span>&#9675;</span>
            <span id="skipped-count">0</span> skipped
          </div>
        </div>
      </div>
    </footer>
  </div>

  <script type="module">
// ============================================
// LIBRARY (bundled inline)
// ============================================
class WikiError extends Error {
  constructor(message) {
    super(message);
    this.name = "WikiError";
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

class ValidationError extends WikiError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "ValidationError";
  }
}

const DEFAULT_LINK_PATTERN = /\[\[([^\]|]+)(?:\|[^\]]*)?\]\]/g;

function extractLinks(content, pattern = DEFAULT_LINK_PATTERN) {
  const cleaned = removeCodeBlocks(content);
  const links = [];
  const seen = new Set();
  pattern.lastIndex = 0;
  const regex = new RegExp(pattern.source, "g");
  let match;
  while ((match = regex.exec(cleaned)) !== null) {
    let linkText = match[1]?.trim();
    if (linkText?.includes("\n")) continue;
    if (linkText) linkText = linkText.replace(/^\[+/, "");
    if (linkText && linkText.length > 0 && !seen.has(linkText)) {
      links.push(linkText);
      seen.add(linkText);
    }
  }
  return links;
}

function removeCodeBlocks(content) {
  let result = content;
  result = result.replace(/```[\s\S]*?```/g, "");
  result = result.replace(/~~~[\s\S]*?~~~/g, "");
  result = result.replace(/``[^`]*?``/g, "");
  result = result.replace(/`[^`\n]*?`/g, "");
  result = result.replace(/^ {4}.*/gm, "");
  return result;
}

function memoryStorage() {
  const store = new Map();
  return {
    save(page) {
      store.set(page.id, { ...page });
      return Promise.resolve();
    },
    load(id) {
      const page = store.get(id);
      return Promise.resolve(page ? { ...page } : null);
    },
    delete(id) {
      store.delete(id);
      return Promise.resolve();
    },
    list() {
      const pages = Array.from(store.values()).map(p => ({ ...p }));
      return Promise.resolve(pages);
    }
  };
}

function createWiki(options) {
  if (options?.storage) {
    const storage = options.storage;
    if (typeof storage.save !== "function" || typeof storage.load !== "function" ||
        typeof storage.delete !== "function" || typeof storage.list !== "function") {
      throw new TypeError("Storage must implement WikiStorage interface");
    }
  }
  if (options?.linkPattern) {
    if (!(options.linkPattern instanceof RegExp)) {
      throw new TypeError("linkPattern must be a RegExp");
    }
    if (!/\([^?]/.test(options.linkPattern.source)) {
      throw new Error("linkPattern must have at least one capture group");
    }
  }

  const storage = options?.storage ?? memoryStorage();
  const linkPattern = options?.linkPattern ?? DEFAULT_LINK_PATTERN;
  const pages = new Map();
  const linkIndex = new Map();
  const backlinkIndex = new Map();
  const listeners = new Set();
  let nextFallbackId = 1;

  function slugify(title) {
    const normalized = title.toLowerCase().trim().normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^\p{L}\p{N}\s-]/gu, "")
      .replace(/\s+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");
    if (normalized) return normalized;
    const fallbackId = `page-${nextFallbackId}`;
    nextFallbackId++;
    return fallbackId;
  }

  function generateUniqueId(baseId) {
    if (!pages.has(baseId)) return baseId;
    let counter = 2;
    while (pages.has(`${baseId}-${counter}`)) counter++;
    return `${baseId}-${counter}`;
  }

  function validatePageData(data, isUpdate = false) {
    if ("title" in data) {
      const title = data.title;
      if (title === undefined) {
        if (!isUpdate) throw new ValidationError("Title is required");
      } else if (typeof title !== "string") {
        throw new ValidationError("Title is required");
      } else if (title.trim() === "") {
        throw new ValidationError("Title cannot be empty");
      }
    } else if (!isUpdate) {
      throw new ValidationError("Title is required");
    }
    if ("tags" in data && data.tags !== undefined) {
      if (!Array.isArray(data.tags)) throw new TypeError("Tags must be an array");
      for (const tag of data.tags) {
        if (typeof tag !== "string" || tag.trim() === "") {
          throw new TypeError("Each tag must be a non-empty string");
        }
      }
    }
    if ("type" in data && data.type !== undefined && typeof data.type !== "string") {
      throw new TypeError("Type must be a string");
    }
  }

  function indexPageLinks(pageId, content) {
    const links = extractLinks(content, linkPattern);
    const linkSet = new Set(links);
    linkIndex.set(pageId, linkSet);
    for (const linkText of links) {
      const targetId = slugify(linkText);
      if (!backlinkIndex.has(targetId)) backlinkIndex.set(targetId, new Set());
      backlinkIndex.get(targetId).add(pageId);
    }
  }

  function removePageFromIndexes(pageId) {
    const links = linkIndex.get(pageId) ?? new Set();
    for (const linkText of links) {
      const targetId = slugify(linkText);
      backlinkIndex.get(targetId)?.delete(pageId);
      if (backlinkIndex.get(targetId)?.size === 0) backlinkIndex.delete(targetId);
    }
    linkIndex.delete(pageId);
    backlinkIndex.delete(pageId);
  }

  function emitEvent(event) {
    for (const listener of listeners) {
      try { listener(event); } catch (e) { console.error("Subscriber error:", e); }
    }
  }

  const wiki = {
    async createPage(data) {
      validatePageData(data);
      const title = data.title;
      const content = data.content ?? "";
      let id;
      if (data.id) {
        if (pages.has(data.id)) throw new Error(`Page with id '${data.id}' already exists`);
        id = data.id;
      } else {
        id = generateUniqueId(slugify(title));
      }
      const now = new Date();
      const page = {
        id, title, content,
        ...(data.type !== undefined && { type: data.type }),
        ...(data.tags !== undefined && { tags: data.tags }),
        created: now, modified: now
      };
      pages.set(id, page);
      indexPageLinks(id, content);
      await storage.save(page);
      emitEvent({ type: "create", page });
      return { ...page };
    },

    getPage(id) {
      if (!id || typeof id !== "string") return undefined;
      const page = pages.get(id);
      return page ? { ...page } : undefined;
    },

    getPageByTitle(title, options) {
      if (!title || typeof title !== "string") return undefined;
      if (options?.ignoreCase) {
        const lower = title.toLowerCase();
        for (const page of pages.values()) {
          if (page.title.toLowerCase() === lower) return { ...page };
        }
        return undefined;
      }
      for (const page of pages.values()) {
        if (page.title === title) return { ...page };
      }
      return undefined;
    },

    async updatePage(id, data) {
      const page = pages.get(id);
      if (!page) throw new Error(`Page '${id}' not found`);
      validatePageData(data, true);
      const previous = { ...page };
      const contentChanged = data.content !== undefined && data.content !== page.content;
      if (data.title !== undefined) page.title = data.title;
      if (data.content !== undefined) page.content = data.content;
      if ("type" in data) {
        if (data.type === undefined) delete page.type;
        else page.type = data.type;
      }
      if ("tags" in data) {
        if (data.tags === undefined) delete page.tags;
        else page.tags = data.tags;
      }
      page.modified = new Date();
      if (contentChanged) {
        removePageFromIndexes(id);
        indexPageLinks(id, page.content);
      }
      pages.set(id, page);
      await storage.save(page);
      emitEvent({ type: "update", page: { ...page }, previous });
      return { ...page };
    },

    async deletePage(id, options) {
      const page = pages.get(id);
      if (!page) throw new Error(`Page '${id}' not found`);
      const deletedPage = { ...page };
      pages.delete(id);
      if (options?.updateLinks !== false) removePageFromIndexes(id);
      await storage.delete(id);
      emitEvent({ type: "delete", page: deletedPage });
    },

    getLinks(id) {
      const links = linkIndex.get(id);
      return links ? Array.from(links) : [];
    },

    getBacklinks(id) {
      const backlinks = backlinkIndex.get(id);
      return backlinks ? Array.from(backlinks) : [];
    },

    getLinkedPages(id) {
      const links = wiki.getLinks(id);
      return links.map(linkText => pages.get(slugify(linkText))).filter(p => p).map(p => ({ ...p }));
    },

    getBacklinkPages(id) {
      return wiki.getBacklinks(id).map(bid => pages.get(bid)).filter(p => p).map(p => ({ ...p }));
    },

    resolveLink(linkText) {
      return slugify(linkText);
    },

    resolveLinkToPage(linkText) {
      return wiki.getPage(wiki.resolveLink(linkText));
    },

    getDeadLinks() {
      const deadLinks = [];
      for (const [sourceId, links] of linkIndex.entries()) {
        for (const linkText of links) {
          if (!pages.has(slugify(linkText))) {
            deadLinks.push({ source: sourceId, target: linkText });
          }
        }
      }
      return deadLinks;
    },

    getDeadLinksForPage(id) {
      const links = linkIndex.get(id);
      if (!links) return [];
      const deadLinks = [];
      for (const linkText of links) {
        if (!pages.has(slugify(linkText))) deadLinks.push(linkText);
      }
      return deadLinks;
    },

    getOrphans() {
      const orphans = [];
      for (const page of pages.values()) {
        const backlinks = backlinkIndex.get(page.id);
        if (!backlinks || backlinks.size === 0) orphans.push({ ...page });
      }
      return orphans;
    },

    getGraph() {
      const graph = {};
      for (const page of pages.values()) {
        const links = linkIndex.get(page.id) ?? new Set();
        graph[page.id] = Array.from(links).map(linkText => slugify(linkText));
      }
      return graph;
    },

    getConnectedPages(id, depth = 1) {
      if (!pages.get(id)) return [];
      const visited = new Set();
      const queue = [{ id, currentDepth: 0 }];
      const connectedIds = new Set();
      while (queue.length > 0) {
        const current = queue.shift();
        if (!current || visited.has(current.id)) continue;
        visited.add(current.id);
        connectedIds.add(current.id);
        if (current.currentDepth < depth) {
          for (const linkText of wiki.getLinks(current.id)) {
            const targetId = slugify(linkText);
            if (!visited.has(targetId) && pages.has(targetId)) {
              queue.push({ id: targetId, currentDepth: current.currentDepth + 1 });
            }
          }
          for (const backlinkId of wiki.getBacklinks(current.id)) {
            if (!visited.has(backlinkId)) {
              queue.push({ id: backlinkId, currentDepth: current.currentDepth + 1 });
            }
          }
        }
      }
      return Array.from(connectedIds).map(pid => pages.get(pid)).filter(p => p).map(p => ({ ...p }));
    },

    listPages(options) {
      let result = Array.from(pages.values());
      if (options?.type) result = result.filter(p => p.type === options.type);
      if (options?.tags?.length > 0) {
        const filterTags = options.tags;
        result = result.filter(p => p.tags && filterTags.some(t => p.tags.includes(t)));
      }
      const sortField = options?.sort ?? "created";
      const order = options?.order ?? "desc";
      result.sort((a, b) => {
        let cmp = 0;
        if (sortField === "title") cmp = a.title.localeCompare(b.title);
        else if (sortField === "created") cmp = a.created.getTime() - b.created.getTime();
        else cmp = a.modified.getTime() - b.modified.getTime();
        return order === "asc" ? cmp : -cmp;
      });
      const offset = options?.offset ?? 0;
      const limit = options?.limit;
      if (limit === 0) return [];
      if (offset > 0 || limit !== undefined) {
        result = result.slice(offset, limit !== undefined ? offset + limit : undefined);
      }
      return result.map(p => ({ ...p }));
    },

    search(query, options) {
      if (!query?.trim()) return [];
      const normalized = query.trim().toLowerCase();
      const fields = options?.fields ?? ["title", "content"];
      const results = [];
      for (const page of pages.values()) {
        if (options?.type && page.type !== options.type) continue;
        let score = 0;
        if (fields.includes("title")) {
          const titleLower = page.title.toLowerCase();
          if (titleLower === normalized) score += 100;
          else if (titleLower.includes(normalized)) score += 50;
        }
        if (fields.includes("content") && page.content.toLowerCase().includes(normalized)) score += 10;
        if (fields.includes("tags") && page.tags) {
          for (const tag of page.tags) {
            if (tag.toLowerCase().includes(normalized)) score += 20;
          }
        }
        if (score > 0) results.push({ page: { ...page }, score });
      }
      results.sort((a, b) => b.score - a.score);
      const limited = options?.limit ? results.slice(0, options.limit) : results;
      return limited.map(r => r.page);
    },

    getTags() {
      const tags = new Set();
      for (const page of pages.values()) {
        if (page.tags) for (const tag of page.tags) tags.add(tag);
      }
      return Array.from(tags).sort();
    },

    getPagesByTag(tag) {
      return Array.from(pages.values()).filter(p => p.tags?.includes(tag)).map(p => ({ ...p }));
    },

    getTypes() {
      const types = new Set();
      for (const page of pages.values()) {
        if (page.type) types.add(page.type);
      }
      return Array.from(types).sort();
    },

    getPagesByType(type) {
      return Array.from(pages.values()).filter(p => p.type === type).map(p => ({ ...p }));
    },

    export() {
      return Array.from(pages.values()).map(p => ({ ...p }));
    },

    async import(pagesData, options) {
      if (!Array.isArray(pagesData)) throw new Error("Pages must be an array");
      for (const pageData of pagesData) {
        if (!pageData.id) throw new Error("Each page must have an id field");
        if (!pageData.title) throw new Error("Each page must have a title field");
      }
      const mode = options?.mode ?? "replace";
      const emitEvents = options?.emitEvents ?? false;
      if (mode === "replace") {
        pages.clear();
        linkIndex.clear();
        backlinkIndex.clear();
      }
      let importCount = 0;
      for (const pageData of pagesData) {
        if (mode === "skip" && pages.has(pageData.id)) continue;
        const page = {
          ...pageData,
          created: pageData.created instanceof Date ? pageData.created : new Date(pageData.created),
          modified: pageData.modified instanceof Date ? pageData.modified : new Date(pageData.modified)
        };
        pages.set(page.id, page);
        indexPageLinks(page.id, page.content);
        await storage.save(page);
        importCount++;
        if (emitEvents) emitEvent({ type: "create", page: { ...page } });
      }
      return importCount;
    },

    toJSON() {
      return JSON.stringify(wiki.export());
    },

    on(event, callback) {
      listeners.add(callback);
      return () => listeners.delete(callback);
    },

    onChange(callback) {
      return wiki.on("change", callback);
    }
  };

  return wiki;
}

// ============================================
// INITIAL DATA
// ============================================

const initialPages = [
  {
    id: 'kingdom-of-valdoria',
    title: 'Kingdom of Valdoria',
    type: 'location',
    tags: ['kingdom', 'main-setting'],
    content: 'A prosperous realm ruled by [[King Aldric]]. Notable places include [[Crystal Spire]] and [[Shadow Forest]].',
    created: new Date('2024-01-01'),
    modified: new Date('2024-01-01')
  },
  {
    id: 'king-aldric',
    title: 'King Aldric',
    type: 'character',
    tags: ['royalty', 'protagonist'],
    content: 'The wise ruler of [[Kingdom of Valdoria]]. Father of [[Princess Elena]]. Wields the legendary [[Sunblade]].',
    created: new Date('2024-01-02'),
    modified: new Date('2024-01-02')
  },
  {
    id: 'princess-elena',
    title: 'Princess Elena',
    type: 'character',
    tags: ['royalty', 'protagonist'],
    content: 'Heir to [[Kingdom of Valdoria]]. Trained in magic at the [[Crystal Spire]]. Seeks the [[Lost Artifact]].',
    created: new Date('2024-01-03'),
    modified: new Date('2024-01-03')
  },
  {
    id: 'crystal-spire',
    title: 'Crystal Spire',
    type: 'location',
    tags: ['magical', 'landmark'],
    content: 'Ancient tower of magic in [[Kingdom of Valdoria]]. Home to the order of mages.',
    created: new Date('2024-01-04'),
    modified: new Date('2024-01-04')
  },
  {
    id: 'shadow-forest',
    title: 'Shadow Forest',
    type: 'location',
    tags: ['dangerous', 'wilderness'],
    content: 'Dark woods on the border of [[Kingdom of Valdoria]]. Rumored home of [[The Dark One]].',
    created: new Date('2024-01-05'),
    modified: new Date('2024-01-05')
  },
  {
    id: 'sunblade',
    title: 'Sunblade',
    type: 'item',
    tags: ['legendary', 'weapon', 'magical'],
    content: 'Legendary sword wielded by [[King Aldric]]. Said to banish darkness.',
    created: new Date('2024-01-06'),
    modified: new Date('2024-01-06')
  }
];

// ============================================
// GLOBAL STATE
// ============================================

let wiki = createWiki();
let cardPositions = new Map();
let selectedCardId = null;
let graphSelectedNode = null;

// ============================================
// EXHIBIT 1: LIVING WIKI
// ============================================

const wikiCanvas = document.getElementById('wiki-canvas');
const wikiSvg = document.getElementById('wiki-connections');
const wikiEditor = document.getElementById('wiki-editor');
const wikiEditorTitle = document.getElementById('wiki-editor-title');
const wikiEditorContent = document.getElementById('wiki-editor-content');

const typeIcons = {
  character: '\u{1F464}',
  location: '\u{1F4CD}',
  item: '\u2694\uFE0F',
  event: '\u{1F4C5}',
  default: '\u{1F4C4}'
};

function getTypeIcon(type) {
  return typeIcons[type] || typeIcons.default;
}

function initializeCardPositions() {
  cardPositions.clear();
  const pages = wiki.listPages();
  const deadLinks = wiki.getDeadLinks();
  const deadTargets = new Set(deadLinks.map(d => d.target));

  // Layout existing pages in a grid
  const cols = 3;
  const startX = 40;
  const startY = 30;
  const gapX = 180;
  const gapY = 120;

  pages.forEach((page, i) => {
    const col = i % cols;
    const row = Math.floor(i / cols);
    cardPositions.set(page.id, {
      x: startX + col * gapX,
      y: startY + row * gapY,
      isGhost: false
    });
  });

  // Add ghost cards for dead links
  let ghostIndex = 0;
  deadTargets.forEach(target => {
    const ghostId = `ghost-${target.toLowerCase().replace(/\s+/g, '-')}`;
    cardPositions.set(ghostId, {
      x: startX + (pages.length % cols + ghostIndex) * gapX,
      y: startY + Math.floor((pages.length + ghostIndex) / cols) * gapY,
      isGhost: true,
      title: target
    });
    ghostIndex++;
  });
}

function renderWikiCards() {
  // Remove existing cards
  wikiCanvas.querySelectorAll('.wiki-card').forEach(el => el.remove());

  const pages = wiki.listPages();
  const deadLinks = wiki.getDeadLinks();
  const deadTargets = new Set(deadLinks.map(d => d.target));
  const orphans = new Set(wiki.getOrphans().map(p => p.id));

  // Render page cards
  pages.forEach(page => {
    const pos = cardPositions.get(page.id);
    if (!pos) return;

    const card = document.createElement('div');
    card.className = 'wiki-card';
    if (orphans.has(page.id)) card.classList.add('orphan');
    if (selectedCardId === page.id) card.classList.add('selected');
    card.dataset.id = page.id;
    card.style.left = `${pos.x}px`;
    card.style.top = `${pos.y}px`;

    card.innerHTML = `
      <div class="wiki-card-title">${escapeHtml(page.title)}</div>
      <div class="wiki-card-type"><span class="type-icon">${getTypeIcon(page.type)}</span>${page.type || 'untyped'}</div>
    `;

    card.addEventListener('mousedown', startDrag);
    card.addEventListener('click', (e) => {
      if (!card.classList.contains('dragging')) selectCard(page.id);
    });

    wikiCanvas.appendChild(card);
  });

  // Render ghost cards
  deadTargets.forEach(target => {
    const ghostId = `ghost-${target.toLowerCase().replace(/\s+/g, '-')}`;
    const pos = cardPositions.get(ghostId);
    if (!pos) return;

    const card = document.createElement('div');
    card.className = 'wiki-card ghost';
    card.dataset.ghostTitle = target;
    card.style.left = `${pos.x}px`;
    card.style.top = `${pos.y}px`;

    card.innerHTML = `
      <div class="wiki-card-title">${escapeHtml(target)}</div>
      <div class="wiki-card-type">dead link</div>
    `;

    card.addEventListener('mousedown', startDrag);
    card.addEventListener('click', () => createFromGhost(target));

    wikiCanvas.appendChild(card);
  });

  renderConnections();
}

function renderConnections() {
  wikiSvg.innerHTML = '';

  const pages = wiki.listPages();
  const graph = wiki.getGraph();
  const deadLinks = wiki.getDeadLinks();

  // Draw connections between existing pages
  for (const page of pages) {
    const sourcePos = cardPositions.get(page.id);
    if (!sourcePos) continue;

    const links = graph[page.id] || [];
    for (const targetId of links) {
      const targetPos = cardPositions.get(targetId);
      if (targetPos && !targetPos.isGhost) {
        const line = createConnectionLine(sourcePos, targetPos, page.id === selectedCardId);
        wikiSvg.appendChild(line);
      }
    }
  }

  // Draw dead link connections
  for (const dead of deadLinks) {
    const sourcePos = cardPositions.get(dead.source);
    const ghostId = `ghost-${dead.target.toLowerCase().replace(/\s+/g, '-')}`;
    const targetPos = cardPositions.get(ghostId);
    if (sourcePos && targetPos) {
      const line = createConnectionLine(sourcePos, targetPos, dead.source === selectedCardId, true);
      wikiSvg.appendChild(line);
    }
  }

  // Draw incoming connections (backlinks) for selected card
  if (selectedCardId) {
    const backlinks = wiki.getBacklinks(selectedCardId);
    for (const sourceId of backlinks) {
      const sourcePos = cardPositions.get(sourceId);
      const targetPos = cardPositions.get(selectedCardId);
      if (sourcePos && targetPos) {
        const line = createConnectionLine(sourcePos, targetPos, false, false, true);
        wikiSvg.appendChild(line);
      }
    }
  }
}

function createConnectionLine(from, to, highlight = false, isDead = false, isIncoming = false) {
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  const cardWidth = 140;
  const cardHeight = 60;

  const fromX = from.x + cardWidth / 2;
  const fromY = from.y + cardHeight / 2;
  const toX = to.x + cardWidth / 2;
  const toY = to.y + cardHeight / 2;

  // Curved path
  const midX = (fromX + toX) / 2;
  const midY = (fromY + toY) / 2;
  const dx = toX - fromX;
  const dy = toY - fromY;
  const offset = Math.min(30, Math.sqrt(dx*dx + dy*dy) / 4);
  const ctrlX = midX - dy * 0.2;
  const ctrlY = midY + dx * 0.2;

  line.setAttribute('d', `M ${fromX} ${fromY} Q ${ctrlX} ${ctrlY} ${toX} ${toY}`);
  line.classList.add('connection-line');
  if (highlight) line.classList.add('highlight');
  if (isDead) line.classList.add('dead');
  if (isIncoming) line.classList.add('incoming');

  return line;
}

let dragState = null;

function startDrag(e) {
  if (e.button !== 0) return;
  const card = e.currentTarget;
  const rect = card.getBoundingClientRect();
  const canvasRect = wikiCanvas.getBoundingClientRect();

  dragState = {
    card,
    id: card.dataset.id || card.dataset.ghostTitle,
    isGhost: card.classList.contains('ghost'),
    startX: e.clientX,
    startY: e.clientY,
    offsetX: e.clientX - rect.left,
    offsetY: e.clientY - rect.top,
    canvasX: canvasRect.left,
    canvasY: canvasRect.top,
    moved: false
  };

  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', endDrag);
}

function onDrag(e) {
  if (!dragState) return;

  const dx = e.clientX - dragState.startX;
  const dy = e.clientY - dragState.startY;

  if (!dragState.moved && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
    dragState.moved = true;
    dragState.card.classList.add('dragging');
  }

  if (dragState.moved) {
    const x = e.clientX - dragState.canvasX - dragState.offsetX;
    const y = e.clientY - dragState.canvasY - dragState.offsetY;
    dragState.card.style.left = `${x}px`;
    dragState.card.style.top = `${y}px`;

    const key = dragState.isGhost ? `ghost-${dragState.id.toLowerCase().replace(/\s+/g, '-')}` : dragState.id;
    const pos = cardPositions.get(key);
    if (pos) {
      pos.x = x;
      pos.y = y;
    }

    renderConnections();
  }
}

function endDrag() {
  if (dragState) {
    dragState.card.classList.remove('dragging');
    dragState = null;
  }
  document.removeEventListener('mousemove', onDrag);
  document.removeEventListener('mouseup', endDrag);
}

function selectCard(id) {
  selectedCardId = id;
  const page = wiki.getPage(id);
  if (page) {
    wikiEditorTitle.value = page.title;
    wikiEditorContent.value = page.content;
    wikiEditor.classList.add('visible');
  }
  renderWikiCards();
}

async function createFromGhost(title) {
  const page = await wiki.createPage({ title, content: '' });
  const ghostId = `ghost-${title.toLowerCase().replace(/\s+/g, '-')}`;
  const ghostPos = cardPositions.get(ghostId);
  if (ghostPos) {
    cardPositions.set(page.id, { x: ghostPos.x, y: ghostPos.y, isGhost: false });
    cardPositions.delete(ghostId);
  }
  selectCard(page.id);
  renderWikiCards();
}

document.getElementById('wiki-save-btn').addEventListener('click', async () => {
  if (!selectedCardId) return;
  await wiki.updatePage(selectedCardId, {
    title: wikiEditorTitle.value,
    content: wikiEditorContent.value
  });
  renderWikiCards();
  renderGraphExplorer();
  renderWorkshop();
});

document.getElementById('wiki-delete-btn').addEventListener('click', async () => {
  if (!selectedCardId) return;
  await wiki.deletePage(selectedCardId);
  cardPositions.delete(selectedCardId);
  selectedCardId = null;
  wikiEditor.classList.remove('visible');
  initializeCardPositions();
  renderWikiCards();
  renderGraphExplorer();
  renderWorkshop();
});

document.getElementById('wiki-new-btn').addEventListener('click', async () => {
  const title = prompt('Page title:');
  if (!title) return;
  const page = await wiki.createPage({ title, content: '' });
  const pages = wiki.listPages();
  const col = (pages.length - 1) % 3;
  const row = Math.floor((pages.length - 1) / 3);
  cardPositions.set(page.id, { x: 40 + col * 180, y: 30 + row * 120, isGhost: false });
  selectCard(page.id);
  renderWikiCards();
  renderGraphExplorer();
  renderWorkshop();
});

document.getElementById('wiki-arrange-btn').addEventListener('click', () => {
  initializeCardPositions();
  renderWikiCards();
});

document.getElementById('wiki-reset-btn').addEventListener('click', async () => {
  wiki = createWiki();
  await wiki.import(initialPages, { mode: 'replace' });
  selectedCardId = 'king-aldric';
  initializeCardPositions();
  renderWikiCards();
  renderGraphExplorer();
  renderWorkshop();
  selectCard('king-aldric');
});

// ============================================
// EXHIBIT 2: GRAPH EXPLORER
// ============================================

const graphSvg = document.getElementById('graph-svg');
const depthSlider = document.getElementById('depth-slider');
const depthValue = document.getElementById('depth-value');
const selectedNodeSpan = document.getElementById('selected-node');
const connectedCountSpan = document.getElementById('connected-count');

let graphNodes = [];
let graphEdges = [];
let graphSimulation = null;

function initializeGraph() {
  const pages = wiki.listPages();
  const graph = wiki.getGraph();

  graphNodes = pages.map(page => ({
    id: page.id,
    title: page.title,
    type: page.type,
    x: Math.random() * 500 + 50,
    y: Math.random() * 300 + 50,
    vx: 0,
    vy: 0
  }));

  graphEdges = [];
  for (const page of pages) {
    const targets = graph[page.id] || [];
    for (const targetId of targets) {
      if (pages.find(p => p.id === targetId)) {
        graphEdges.push({ source: page.id, target: targetId });
      }
    }
  }

  graphSelectedNode = 'kingdom-of-valdoria';
}

function renderGraphExplorer() {
  initializeGraph();

  graphSvg.innerHTML = '';
  const width = graphSvg.clientWidth || 600;
  const height = 400;

  // Create edges
  const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  edgeGroup.id = 'edges';
  graphSvg.appendChild(edgeGroup);

  for (const edge of graphEdges) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.classList.add('graph-edge');
    line.dataset.source = edge.source;
    line.dataset.target = edge.target;
    edgeGroup.appendChild(line);
  }

  // Create nodes
  const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  nodeGroup.id = 'nodes';
  graphSvg.appendChild(nodeGroup);

  for (const node of graphNodes) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.classList.add('graph-node');
    g.dataset.id = node.id;
    if (node.id === graphSelectedNode) g.classList.add('selected');

    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('r', 20);
    circle.setAttribute('fill', getNodeColor(node.type));
    g.appendChild(circle);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('dy', 35);
    text.textContent = node.title.length > 12 ? node.title.slice(0, 10) + '...' : node.title;
    g.appendChild(text);

    g.addEventListener('click', () => {
      graphSelectedNode = node.id;
      updateGraphSelection();
    });

    g.addEventListener('mousedown', startGraphDrag);

    nodeGroup.appendChild(g);
  }

  startGraphSimulation();
  updateGraphSelection();
}

function getNodeColor(type) {
  const colors = {
    character: '#58a6ff',
    location: '#3fb950',
    item: '#d29922',
    event: '#8957e5'
  };
  return colors[type] || '#8b949e';
}

function startGraphSimulation() {
  if (graphSimulation) cancelAnimationFrame(graphSimulation);

  const width = graphSvg.clientWidth || 600;
  const height = 400;
  const centerX = width / 2;
  const centerY = height / 2;

  let iteration = 0;
  const maxIterations = 200;

  function simulate() {
    // Apply forces
    for (const node of graphNodes) {
      node.vx *= 0.9;
      node.vy *= 0.9;

      // Center gravity
      node.vx += (centerX - node.x) * 0.001;
      node.vy += (centerY - node.y) * 0.001;

      // Repulsion between nodes
      for (const other of graphNodes) {
        if (node === other) continue;
        const dx = node.x - other.x;
        const dy = node.y - other.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const force = 1000 / (dist * dist);
        node.vx += (dx / dist) * force;
        node.vy += (dy / dist) * force;
      }
    }

    // Edge attraction
    for (const edge of graphEdges) {
      const source = graphNodes.find(n => n.id === edge.source);
      const target = graphNodes.find(n => n.id === edge.target);
      if (!source || !target) continue;

      const dx = target.x - source.x;
      const dy = target.y - source.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const force = (dist - 100) * 0.01;

      source.vx += (dx / dist) * force;
      source.vy += (dy / dist) * force;
      target.vx -= (dx / dist) * force;
      target.vy -= (dy / dist) * force;
    }

    // Update positions
    for (const node of graphNodes) {
      node.x += node.vx;
      node.y += node.vy;
      node.x = Math.max(30, Math.min(width - 30, node.x));
      node.y = Math.max(30, Math.min(height - 30, node.y));
    }

    updateGraphPositions();

    iteration++;
    if (iteration < maxIterations) {
      graphSimulation = requestAnimationFrame(simulate);
    }
  }

  simulate();
}

function updateGraphPositions() {
  for (const node of graphNodes) {
    const g = graphSvg.querySelector(`g[data-id="${node.id}"]`);
    if (g) {
      g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
    }
  }

  for (const edge of graphEdges) {
    const source = graphNodes.find(n => n.id === edge.source);
    const target = graphNodes.find(n => n.id === edge.target);
    const line = graphSvg.querySelector(`line[data-source="${edge.source}"][data-target="${edge.target}"]`);
    if (line && source && target) {
      line.setAttribute('x1', source.x);
      line.setAttribute('y1', source.y);
      line.setAttribute('x2', target.x);
      line.setAttribute('y2', target.y);
    }
  }
}

function updateGraphSelection() {
  const depth = parseInt(depthSlider.value);
  depthValue.textContent = depth;

  // Clear all lit states
  graphSvg.querySelectorAll('.graph-node').forEach(g => {
    g.classList.remove('selected', 'lit', 'lit-1', 'lit-2', 'lit-3');
  });
  graphSvg.querySelectorAll('.graph-edge').forEach(e => {
    e.classList.remove('highlight');
  });

  if (!graphSelectedNode) return;

  // Mark selected node
  const selectedG = graphSvg.querySelector(`g[data-id="${graphSelectedNode}"]`);
  if (selectedG) selectedG.classList.add('selected', 'lit');

  // Get connected pages at each depth
  const connectedByDepth = new Map();
  connectedByDepth.set(graphSelectedNode, 0);

  for (let d = 1; d <= depth; d++) {
    const prevDepthNodes = Array.from(connectedByDepth.entries())
      .filter(([id, nodeDepth]) => nodeDepth === d - 1)
      .map(([id]) => id);

    for (const nodeId of prevDepthNodes) {
      const outgoing = graphEdges.filter(e => e.source === nodeId).map(e => e.target);
      const incoming = graphEdges.filter(e => e.target === nodeId).map(e => e.source);

      for (const connectedId of [...outgoing, ...incoming]) {
        if (!connectedByDepth.has(connectedId)) {
          connectedByDepth.set(connectedId, d);
        }
      }
    }
  }

  // Animate ripple effect
  let animationDelay = 0;
  for (let d = 1; d <= depth; d++) {
    const nodesAtDepth = Array.from(connectedByDepth.entries())
      .filter(([id, nodeDepth]) => nodeDepth === d)
      .map(([id]) => id);

    setTimeout(() => {
      for (const nodeId of nodesAtDepth) {
        const g = graphSvg.querySelector(`g[data-id="${nodeId}"]`);
        if (g) g.classList.add('lit', `lit-${d}`);
      }

      // Highlight edges
      for (const edge of graphEdges) {
        const sourceDepth = connectedByDepth.get(edge.source);
        const targetDepth = connectedByDepth.get(edge.target);
        if (sourceDepth !== undefined && targetDepth !== undefined &&
            (sourceDepth <= d && targetDepth <= d)) {
          const line = graphSvg.querySelector(`line[data-source="${edge.source}"][data-target="${edge.target}"]`);
          if (line) line.classList.add('highlight');
        }
      }
    }, animationDelay);

    animationDelay += 200;
  }

  // Update info
  const page = wiki.getPage(graphSelectedNode);
  selectedNodeSpan.textContent = page ? page.title : graphSelectedNode;
  const connectedCount = connectedByDepth.size - 1;
  connectedCountSpan.textContent = `(${connectedCount} connected at depth ${depth})`;
}

let graphDragState = null;

function startGraphDrag(e) {
  const g = e.currentTarget;
  const nodeId = g.dataset.id;
  const node = graphNodes.find(n => n.id === nodeId);
  if (!node) return;

  graphDragState = { node, startX: e.clientX, startY: e.clientY };
  g.classList.add('dragging');

  document.addEventListener('mousemove', onGraphDrag);
  document.addEventListener('mouseup', endGraphDrag);
  e.preventDefault();
}

function onGraphDrag(e) {
  if (!graphDragState) return;

  const rect = graphSvg.getBoundingClientRect();
  graphDragState.node.x = e.clientX - rect.left;
  graphDragState.node.y = e.clientY - rect.top;
  graphDragState.node.vx = 0;
  graphDragState.node.vy = 0;

  updateGraphPositions();
}

function endGraphDrag() {
  if (graphDragState) {
    const g = graphSvg.querySelector(`g[data-id="${graphDragState.node.id}"]`);
    if (g) g.classList.remove('dragging');
    graphDragState = null;
  }
  document.removeEventListener('mousemove', onGraphDrag);
  document.removeEventListener('mouseup', endGraphDrag);
}

depthSlider.addEventListener('input', updateGraphSelection);

document.getElementById('graph-shake-btn').addEventListener('click', () => {
  for (const node of graphNodes) {
    node.vx += (Math.random() - 0.5) * 50;
    node.vy += (Math.random() - 0.5) * 50;
  }
  startGraphSimulation();
});

document.getElementById('graph-fit-btn').addEventListener('click', () => {
  const width = graphSvg.clientWidth || 600;
  const height = 400;
  const margin = 50;

  if (graphNodes.length === 0) return;

  const minX = Math.min(...graphNodes.map(n => n.x));
  const maxX = Math.max(...graphNodes.map(n => n.x));
  const minY = Math.min(...graphNodes.map(n => n.y));
  const maxY = Math.max(...graphNodes.map(n => n.y));

  const scaleX = (width - 2 * margin) / (maxX - minX || 1);
  const scaleY = (height - 2 * margin) / (maxY - minY || 1);
  const scale = Math.min(scaleX, scaleY, 1);

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  for (const node of graphNodes) {
    node.x = (node.x - centerX) * scale + width / 2;
    node.y = (node.y - centerY) * scale + height / 2;
  }

  updateGraphPositions();
});

document.getElementById('graph-labels-toggle').addEventListener('change', (e) => {
  graphSvg.querySelectorAll('.graph-node text').forEach(text => {
    text.style.display = e.target.checked ? '' : 'none';
  });
});

// ============================================
// EXHIBIT 3: TAG & TYPE WORKSHOP
// ============================================

const typeBuckets = document.getElementById('type-buckets');
const tagBuckets = document.getElementById('tag-buckets');
const workshopSearchInput = document.getElementById('workshop-search-input');

function renderWorkshop() {
  renderTypeBuckets();
  renderTagBuckets();
}

function renderTypeBuckets() {
  typeBuckets.innerHTML = '';

  const types = wiki.getTypes();
  const allPages = wiki.listPages();
  const untypedPages = allPages.filter(p => !p.type);

  for (const type of types) {
    const pages = wiki.getPagesByType(type);
    const bucket = createBucket(getTypeIcon(type) + ' ' + type, pages, 'type', type);
    typeBuckets.appendChild(bucket);
  }

  // Untyped bucket
  if (untypedPages.length > 0) {
    const bucket = createBucket('Untyped', untypedPages, 'type', null);
    typeBuckets.appendChild(bucket);
  }
}

function renderTagBuckets() {
  tagBuckets.innerHTML = '';

  const tags = wiki.getTags();

  for (const tag of tags) {
    const pages = wiki.getPagesByTag(tag);
    const bucket = createBucket('\u{1F3F7}\uFE0F ' + tag, pages, 'tag', tag);
    tagBuckets.appendChild(bucket);
  }
}

function createBucket(label, pages, bucketType, value) {
  const bucket = document.createElement('div');
  bucket.className = 'bucket';
  bucket.dataset.bucketType = bucketType;
  bucket.dataset.value = value || '';

  bucket.innerHTML = `
    <div class="bucket-header">${label}</div>
    <div class="bucket-chips"></div>
  `;

  const chipsContainer = bucket.querySelector('.bucket-chips');

  for (const page of pages) {
    const chip = createPageChip(page);
    chipsContainer.appendChild(chip);
  }

  // Drop handling
  bucket.addEventListener('dragover', (e) => {
    e.preventDefault();
    bucket.classList.add('drop-target');
  });

  bucket.addEventListener('dragleave', () => {
    bucket.classList.remove('drop-target');
  });

  bucket.addEventListener('drop', async (e) => {
    e.preventDefault();
    bucket.classList.remove('drop-target');

    const pageId = e.dataTransfer.getData('text/plain');
    const page = wiki.getPage(pageId);
    if (!page) return;

    if (bucketType === 'type') {
      await wiki.updatePage(pageId, { type: value || undefined });
    } else if (bucketType === 'tag' && value) {
      const currentTags = page.tags || [];
      if (!currentTags.includes(value)) {
        await wiki.updatePage(pageId, { tags: [...currentTags, value] });
      }
    }

    renderWorkshop();
  });

  return bucket;
}

function createPageChip(page) {
  const chip = document.createElement('div');
  chip.className = 'page-chip';
  chip.draggable = true;
  chip.dataset.id = page.id;
  chip.textContent = page.title.length > 15 ? page.title.slice(0, 13) + '...' : page.title;
  chip.title = page.title;

  chip.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', page.id);
    chip.classList.add('dragging');
  });

  chip.addEventListener('dragend', () => {
    chip.classList.remove('dragging');
  });

  chip.addEventListener('click', () => {
    // Highlight all instances of this page
    document.querySelectorAll(`.page-chip[data-id="${page.id}"]`).forEach(c => {
      c.classList.add('highlight');
      setTimeout(() => c.classList.remove('highlight'), 1000);
    });
  });

  return chip;
}

workshopSearchInput.addEventListener('input', (e) => {
  const query = e.target.value.toLowerCase();

  document.querySelectorAll('.page-chip').forEach(chip => {
    const title = chip.title.toLowerCase();
    if (query && title.includes(query)) {
      chip.classList.add('highlight');
    } else {
      chip.classList.remove('highlight');
    }
  });
});

document.getElementById('add-type-btn').addEventListener('click', async () => {
  const name = prompt('Type name:');
  if (!name) return;
  // Types are created implicitly when assigned to pages
  alert('Create a page with this type, or drag a page to this bucket.');
});

document.getElementById('add-tag-btn').addEventListener('click', async () => {
  const name = prompt('Tag name:');
  if (!name) return;
  // Tags are created implicitly when assigned to pages
  alert('Add this tag to a page to create the bucket.');
});

document.getElementById('workshop-reset-btn').addEventListener('click', async () => {
  wiki = createWiki();
  await wiki.import(initialPages, { mode: 'replace' });
  renderWorkshop();
  renderWikiCards();
  renderGraphExplorer();
});

// ============================================
// TEST RUNNER
// ============================================

const testRunner = {
  tests: [],
  results: [],
  running: false,

  register(name, fn) {
    this.tests.push({ name, fn });
  },

  async run() {
    if (this.running) return;
    this.running = true;
    this.results = [];

    const output = document.getElementById('test-output');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const summary = document.getElementById('test-summary');
    const passedCount = document.getElementById('passed-count');
    const failedCount = document.getElementById('failed-count');
    const skippedCount = document.getElementById('skipped-count');
    const runBtn = document.getElementById('run-tests');

    runBtn.disabled = true;
    output.innerHTML = '';
    summary.classList.add('hidden');
    progressFill.style.width = '0%';
    progressFill.className = 'test-progress-fill';

    // Run visual demo first
    progressText.textContent = 'Running visual demonstration...';
    output.innerHTML = '<div class="test-output-empty">Demonstrating all exhibits - watch the page!</div>';
    await visualDemo.run();

    // Reset wiki state after visual demo before running tests
    wiki = createWiki();
    await wiki.import(initialPages, { mode: 'replace' });
    selectedCardId = 'king-aldric';
    initializeCardPositions();
    renderWikiCards();
    renderGraphExplorer();
    renderWorkshop();
    selectCard('king-aldric');

    output.innerHTML = '';
    progressText.textContent = 'Running tests...';

    let passed = 0;
    let failed = 0;

    for (let i = 0; i < this.tests.length; i++) {
      const test = this.tests[i];
      const progress = ((i + 1) / this.tests.length) * 100;

      progressFill.style.width = `${progress}%`;
      progressText.textContent = `Running: ${test.name}`;

      try {
        await test.fn();
        passed++;
        this.results.push({ name: test.name, passed: true });
        output.innerHTML += `
          <div class="test-item">
            <span class="test-icon pass">&#10003;</span>
            <span class="test-name">${escapeHtml(test.name)}</span>
          </div>
        `;
      } catch (e) {
        failed++;
        this.results.push({ name: test.name, passed: false, error: e.message });
        output.innerHTML += `
          <div class="test-item">
            <span class="test-icon fail">&#10007;</span>
            <div>
              <div class="test-name">${escapeHtml(test.name)}</div>
              <div class="test-error">${escapeHtml(e.message)}</div>
            </div>
          </div>
        `;
      }

      output.scrollTop = output.scrollHeight;
      await new Promise(r => setTimeout(r, 20));
    }

    progressFill.classList.add(failed === 0 ? 'success' : 'failure');
    progressText.textContent = `Complete: ${passed}/${this.tests.length} passed`;

    passedCount.textContent = passed;
    failedCount.textContent = failed;
    skippedCount.textContent = 0;
    summary.classList.remove('hidden');

    runBtn.disabled = false;
    this.running = false;
  }
};

function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

document.getElementById('run-tests').addEventListener('click', () => testRunner.run());

// ============================================
// REGISTER TESTS
// ============================================

// Wiki Creation
testRunner.register('creates wiki instance with no options', () => {
  const w = createWiki();
  if (!w) throw new Error('Expected wiki instance');
});

testRunner.register('starts with no pages', () => {
  const w = createWiki();
  const pages = w.listPages();
  if (pages.length !== 0) throw new Error('Expected empty pages');
});

testRunner.register('returns object with all documented methods', () => {
  const w = createWiki();
  const methods = ['createPage', 'getPage', 'updatePage', 'deletePage', 'listPages', 'search',
    'getLinks', 'getBacklinks', 'getDeadLinks', 'getOrphans', 'getGraph', 'getConnectedPages',
    'getTags', 'getTypes', 'export', 'import', 'onChange'];
  for (const m of methods) {
    if (typeof w[m] !== 'function') throw new Error(`Missing method: ${m}`);
  }
});

// Page Creation
testRunner.register('creates page with title only', async () => {
  const w = createWiki();
  const page = await w.createPage({ title: 'Test Page' });
  if (!page.id) throw new Error('Expected page id');
  if (page.title !== 'Test Page') throw new Error('Wrong title');
});

testRunner.register('creates page with all fields', async () => {
  const w = createWiki();
  const page = await w.createPage({
    title: 'Full Page',
    content: 'Content here',
    type: 'article',
    tags: ['test', 'demo']
  });
  if (page.content !== 'Content here') throw new Error('Wrong content');
  if (page.type !== 'article') throw new Error('Wrong type');
  if (!page.tags.includes('test')) throw new Error('Missing tag');
});

testRunner.register('generates slug id from title', async () => {
  const w = createWiki();
  const page = await w.createPage({ title: 'My Test Page' });
  if (page.id !== 'my-test-page') throw new Error(`Wrong id: ${page.id}`);
});

testRunner.register('sets created and modified timestamps', async () => {
  const w = createWiki();
  const page = await w.createPage({ title: 'Timestamped' });
  if (!(page.created instanceof Date)) throw new Error('created not a Date');
  if (!(page.modified instanceof Date)) throw new Error('modified not a Date');
});

testRunner.register('throws on empty title', async () => {
  const w = createWiki();
  try {
    await w.createPage({ title: '' });
    throw new Error('Should have thrown');
  } catch (e) {
    if (!e.message.includes('empty')) throw new Error('Wrong error message');
  }
});

// Page Retrieval
testRunner.register('getPage returns page by id', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Findable' });
  const page = w.getPage('findable');
  if (!page || page.title !== 'Findable') throw new Error('Page not found');
});

testRunner.register('getPage returns undefined for non-existent', () => {
  const w = createWiki();
  const page = w.getPage('nonexistent');
  if (page !== undefined) throw new Error('Should be undefined');
});

testRunner.register('getPageByTitle finds by exact title', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Exact Title' });
  const page = w.getPageByTitle('Exact Title');
  if (!page) throw new Error('Page not found');
});

testRunner.register('getPageByTitle case-insensitive option', async () => {
  const w = createWiki();
  await w.createPage({ title: 'CamelCase' });
  const page = w.getPageByTitle('camelcase', { ignoreCase: true });
  if (!page) throw new Error('Page not found');
});

// Page Update
testRunner.register('updatePage changes content', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Updatable' });
  await w.updatePage('updatable', { content: 'New content' });
  const page = w.getPage('updatable');
  if (page.content !== 'New content') throw new Error('Content not updated');
});

testRunner.register('updatePage changes modified timestamp', async () => {
  const w = createWiki();
  const created = await w.createPage({ title: 'Time Test' });
  await new Promise(r => setTimeout(r, 10));
  await w.updatePage('time-test', { content: 'Changed' });
  const updated = w.getPage('time-test');
  if (updated.modified.getTime() <= created.modified.getTime()) {
    throw new Error('Modified time not updated');
  }
});

// Page Deletion
testRunner.register('deletePage removes page', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Deletable' });
  await w.deletePage('deletable');
  if (w.getPage('deletable')) throw new Error('Page still exists');
});

testRunner.register('deletePage throws for non-existent', async () => {
  const w = createWiki();
  try {
    await w.deletePage('ghost');
    throw new Error('Should have thrown');
  } catch (e) {
    if (!e.message.includes('not found')) throw new Error('Wrong error');
  }
});

// Links
testRunner.register('extracts links from content', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Linker', content: 'See [[Target One]] and [[Target Two]]' });
  const links = w.getLinks('linker');
  if (links.length !== 2) throw new Error(`Expected 2 links, got ${links.length}`);
});

testRunner.register('getBacklinks returns linking pages', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Source', content: '[[Target]]' });
  await w.createPage({ title: 'Target', content: '' });
  const backlinks = w.getBacklinks('target');
  if (!backlinks.includes('source')) throw new Error('Missing backlink');
});

testRunner.register('resolveLink converts title to id', () => {
  const w = createWiki();
  const id = w.resolveLink('My Page Title');
  if (id !== 'my-page-title') throw new Error(`Wrong id: ${id}`);
});

// Dead Links
testRunner.register('getDeadLinks finds broken links', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Orphan Linker', content: '[[Nonexistent Page]]' });
  const dead = w.getDeadLinks();
  if (dead.length !== 1) throw new Error('Expected 1 dead link');
  if (dead[0].target !== 'Nonexistent Page') throw new Error('Wrong dead link target');
});

testRunner.register('getDeadLinksForPage returns page-specific dead links', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Broken', content: '[[Missing]]' });
  const dead = w.getDeadLinksForPage('broken');
  if (dead.length !== 1) throw new Error('Expected 1 dead link');
});

// Orphans
testRunner.register('getOrphans finds unlinked pages', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Connected', content: '' });
  await w.createPage({ title: 'Linker', content: '[[Connected]]' });
  await w.createPage({ title: 'Lonely', content: '' });
  const orphans = w.getOrphans();
  const orphanTitles = orphans.map(p => p.title);
  if (!orphanTitles.includes('Lonely')) throw new Error('Missing orphan');
  if (!orphanTitles.includes('Linker')) throw new Error('Linker should be orphan too');
});

// Graph
testRunner.register('getGraph returns adjacency list', async () => {
  const w = createWiki();
  await w.createPage({ title: 'A', content: '[[B]]' });
  await w.createPage({ title: 'B', content: '[[A]]' });
  const graph = w.getGraph();
  if (!graph['a'] || !graph['a'].includes('b')) throw new Error('Missing edge A->B');
  if (!graph['b'] || !graph['b'].includes('a')) throw new Error('Missing edge B->A');
});

testRunner.register('getConnectedPages with depth 1', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Center', content: '[[Near]]' });
  await w.createPage({ title: 'Near', content: '[[Far]]' });
  await w.createPage({ title: 'Far', content: '' });
  const connected = w.getConnectedPages('center', 1);
  const titles = connected.map(p => p.title);
  if (!titles.includes('Center')) throw new Error('Missing Center');
  if (!titles.includes('Near')) throw new Error('Missing Near');
  if (titles.includes('Far')) throw new Error('Far should not be at depth 1');
});

testRunner.register('getConnectedPages with depth 2', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Center', content: '[[Near]]' });
  await w.createPage({ title: 'Near', content: '[[Far]]' });
  await w.createPage({ title: 'Far', content: '' });
  const connected = w.getConnectedPages('center', 2);
  const titles = connected.map(p => p.title);
  if (!titles.includes('Far')) throw new Error('Far should be at depth 2');
});

// Search
testRunner.register('search finds by title', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Searchable Page' });
  await w.createPage({ title: 'Other' });
  const results = w.search('searchable');
  if (results.length !== 1) throw new Error('Expected 1 result');
});

testRunner.register('search finds by content', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Doc', content: 'unique keyword here' });
  const results = w.search('keyword');
  if (results.length !== 1) throw new Error('Expected 1 result');
});

testRunner.register('search respects limit option', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Match A' });
  await w.createPage({ title: 'Match B' });
  await w.createPage({ title: 'Match C' });
  const results = w.search('match', { limit: 2 });
  if (results.length !== 2) throw new Error('Expected 2 results');
});

// Tags & Types
testRunner.register('getTags returns all unique tags', async () => {
  const w = createWiki();
  await w.createPage({ title: 'A', tags: ['foo', 'bar'] });
  await w.createPage({ title: 'B', tags: ['bar', 'baz'] });
  const tags = w.getTags();
  if (!tags.includes('foo') || !tags.includes('bar') || !tags.includes('baz')) {
    throw new Error('Missing tags');
  }
});

testRunner.register('getPagesByTag returns matching pages', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Tagged', tags: ['special'] });
  await w.createPage({ title: 'Untagged' });
  const pages = w.getPagesByTag('special');
  if (pages.length !== 1 || pages[0].title !== 'Tagged') {
    throw new Error('Wrong pages returned');
  }
});

testRunner.register('getTypes returns all unique types', async () => {
  const w = createWiki();
  await w.createPage({ title: 'A', type: 'article' });
  await w.createPage({ title: 'B', type: 'note' });
  const types = w.getTypes();
  if (!types.includes('article') || !types.includes('note')) {
    throw new Error('Missing types');
  }
});

testRunner.register('getPagesByType returns matching pages', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Article', type: 'article' });
  await w.createPage({ title: 'Note', type: 'note' });
  const pages = w.getPagesByType('article');
  if (pages.length !== 1 || pages[0].title !== 'Article') {
    throw new Error('Wrong pages returned');
  }
});

// listPages
testRunner.register('listPages returns all pages', async () => {
  const w = createWiki();
  await w.createPage({ title: 'One' });
  await w.createPage({ title: 'Two' });
  const pages = w.listPages();
  if (pages.length !== 2) throw new Error('Expected 2 pages');
});

testRunner.register('listPages filters by type', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Article', type: 'article' });
  await w.createPage({ title: 'Note', type: 'note' });
  const pages = w.listPages({ type: 'article' });
  if (pages.length !== 1) throw new Error('Expected 1 page');
});

testRunner.register('listPages supports pagination', async () => {
  const w = createWiki();
  for (let i = 0; i < 5; i++) {
    await w.createPage({ title: `Page ${i}` });
  }
  const page1 = w.listPages({ limit: 2, offset: 0 });
  const page2 = w.listPages({ limit: 2, offset: 2 });
  if (page1.length !== 2 || page2.length !== 2) throw new Error('Wrong pagination');
});

// Import/Export
testRunner.register('export returns all pages', async () => {
  const w = createWiki();
  await w.createPage({ title: 'Exportable' });
  const data = w.export();
  if (data.length !== 1) throw new Error('Expected 1 page');
});

testRunner.register('import loads pages', async () => {
  const w = createWiki();
  await w.import([
    { id: 'test', title: 'Imported', content: '', created: new Date(), modified: new Date() }
  ]);
  const page = w.getPage('test');
  if (!page || page.title !== 'Imported') throw new Error('Import failed');
});

testRunner.register('import mode skip preserves existing', async () => {
  const w = createWiki();
  await w.createPage({ id: 'existing', title: 'Original' });
  await w.import([
    { id: 'existing', title: 'New', content: '', created: new Date(), modified: new Date() }
  ], { mode: 'skip' });
  const page = w.getPage('existing');
  if (page.title !== 'Original') throw new Error('Skip mode failed');
});

// Events
testRunner.register('onChange fires on create', async () => {
  const w = createWiki();
  let fired = false;
  w.onChange((e) => { if (e.type === 'create') fired = true; });
  await w.createPage({ title: 'Event Test' });
  if (!fired) throw new Error('Event not fired');
});

testRunner.register('onChange fires on update', async () => {
  const w = createWiki();
  let fired = false;
  await w.createPage({ title: 'Update Test' });
  w.onChange((e) => { if (e.type === 'update') fired = true; });
  await w.updatePage('update-test', { content: 'Changed' });
  if (!fired) throw new Error('Event not fired');
});

testRunner.register('onChange fires on delete', async () => {
  const w = createWiki();
  let fired = false;
  await w.createPage({ title: 'Delete Test' });
  w.onChange((e) => { if (e.type === 'delete') fired = true; });
  await w.deletePage('delete-test');
  if (!fired) throw new Error('Event not fired');
});

testRunner.register('unsubscribe stops events', async () => {
  const w = createWiki();
  let count = 0;
  const unsub = w.onChange(() => count++);
  await w.createPage({ title: 'First' });
  unsub();
  await w.createPage({ title: 'Second' });
  if (count !== 1) throw new Error('Unsubscribe failed');
});

// ============================================
// VISUAL DEMO - Automated exhibit demonstration
// ============================================

const visualDemo = {
  running: false,

  async delay(ms) {
    return new Promise(r => setTimeout(r, ms));
  },

  scrollToElement(el) {
    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
  },

  async run() {
    if (this.running) return;
    this.running = true;

    try {
      // ===== EXHIBIT 1: Living Wiki =====
      this.scrollToElement(document.getElementById('wiki-canvas'));
      await this.delay(300);

      // Select different cards in sequence
      const cardIds = ['kingdom-of-valdoria', 'princess-elena', 'shadow-forest', 'sunblade', 'king-aldric'];
      for (const id of cardIds) {
        selectCard(id);
        renderWikiCards();
        await this.delay(400);
      }

      // Demonstrate typing a new link
      const originalContent = wikiEditorContent.value;
      wikiEditorContent.value = originalContent + ' Ally of [[Queen Mira]].';
      wikiEditorContent.focus();
      await this.delay(300);

      // Save to show new ghost card appearing
      await wiki.updatePage('king-aldric', {
        title: wikiEditorTitle.value,
        content: wikiEditorContent.value
      });
      initializeCardPositions();
      renderWikiCards();
      await this.delay(600);

      // Click on a ghost card to create it
      const ghostTitle = 'Queen Mira';
      await wiki.createPage({ title: ghostTitle, content: 'The mysterious queen.', type: 'character', tags: ['royalty'] });
      const ghostId = `ghost-${ghostTitle.toLowerCase().replace(/\s+/g, '-')}`;
      const ghostPos = cardPositions.get(ghostId);
      if (ghostPos) {
        cardPositions.set('queen-mira', { x: ghostPos.x, y: ghostPos.y, isGhost: false });
        cardPositions.delete(ghostId);
      } else {
        cardPositions.set('queen-mira', { x: 500, y: 250, isGhost: false });
      }
      selectCard('queen-mira');
      renderWikiCards();
      await this.delay(600);

      // Auto-arrange cards
      initializeCardPositions();
      renderWikiCards();
      await this.delay(400);

      // ===== EXHIBIT 2: Graph Explorer =====
      this.scrollToElement(document.getElementById('graph-canvas'));
      renderGraphExplorer();
      await this.delay(400);

      // Select different nodes
      const nodeIds = ['king-aldric', 'crystal-spire', 'sunblade', 'kingdom-of-valdoria'];
      for (const id of nodeIds) {
        graphSelectedNode = id;
        updateGraphSelection();
        await this.delay(350);
      }

      // Animate depth slider
      for (let d = 0; d <= 3; d++) {
        depthSlider.value = d;
        updateGraphSelection();
        await this.delay(300);
      }
      for (let d = 3; d >= 1; d--) {
        depthSlider.value = d;
        updateGraphSelection();
        await this.delay(200);
      }

      // Shake the graph
      document.getElementById('graph-shake-btn').click();
      await this.delay(800);

      // Fit view
      document.getElementById('graph-fit-btn').click();
      await this.delay(400);

      // Toggle labels off and on
      document.getElementById('graph-labels-toggle').click();
      await this.delay(400);
      document.getElementById('graph-labels-toggle').click();
      await this.delay(300);

      // ===== EXHIBIT 3: Tag & Type Workshop =====
      this.scrollToElement(document.getElementById('workshop-container'));
      renderWorkshop();
      await this.delay(400);

      // Search for different terms
      const searchTerms = ['King', 'magic', 'royal', 'forest', 'legend', ''];
      for (const term of searchTerms) {
        workshopSearchInput.value = term;
        workshopSearchInput.dispatchEvent(new Event('input'));
        await this.delay(350);
      }

      // Highlight individual chips by clicking them
      const chips = document.querySelectorAll('.page-chip');
      for (let i = 0; i < Math.min(4, chips.length); i++) {
        chips[i].click();
        await this.delay(400);
      }

      // ===== Final: Scroll to test runner =====
      this.scrollToElement(document.querySelector('.test-runner'));
      await this.delay(200);

    } finally {
      this.running = false;
    }
  }
};

// ============================================
// INITIALIZATION
// ============================================

async function initialize() {
  await wiki.import(initialPages, { mode: 'replace' });
  selectedCardId = 'king-aldric';
  initializeCardPositions();
  renderWikiCards();
  renderGraphExplorer();
  renderWorkshop();

  // Select King Aldric to show editor
  selectCard('king-aldric');

  // Pre-fill search to demonstrate highlight
  workshopSearchInput.value = 'King';
  workshopSearchInput.dispatchEvent(new Event('input'));

  // Clear search after 2 seconds
  setTimeout(() => {
    workshopSearchInput.value = '';
    workshopSearchInput.dispatchEvent(new Event('input'));
  }, 2000);

  // Play initial graph ripple animation
  setTimeout(() => {
    depthSlider.value = 2;
    updateGraphSelection();
    setTimeout(() => {
      depthSlider.value = 1;
      updateGraphSelection();
    }, 600);
  }, 500);
}

initialize();
  </script>
</body>
</html>
